<!DOCTYPE html><html lang="es"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>TV</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#121212">
    <link rel="manifest" href="data:application/manifest+json;base64,ewogICJuYW1lIjogIlRWIiwKICAic2hvcnRfbmFtZSI6ICJUViIsCiAgInN0YXJ0X3VybCI6ICIuLyIsCiAgImRpc3BsYXkiOiAic3RhbmRhbG9uZSIsCiAgImJhY2tncm91bmRfY29sb3IiOiAiIzEyMTIxMiIsCiAgInRoZW1lX2NvbG9yIjogIiMxMjEyMTIiLAogICJpY29ucyI6IFsKICAgIHsKICAgICAgInNyYyI6ICJkYXRhOmltYWdlL3N2Zyt4bWwsPHN2ZyB4bWxucz0lMjJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyUyMiB2aWV3Qm94PSUyMjAgMCAxMDAgMTAwJTIyPjxyZWN0IHdpZHRoPSUyMjEwMCUyMiBoZWlnaHQ9JTIyMTAwJTIyIGZpbGw9JTIyIzEyMTIxMiUyMi8+PHRleHQgeT0lMjIuNTVlbSUyMiB4PSUyMjUwJTIyIGZpbGw9JTIycmVkJTIyIGZvbnQtc2l6ZT0lMjI3MCUyMiB0ZXh0LWFuY2hvcj0lMjJtaWRkbGUlMjIgZG9taW5hbnQtYmFzZWxpbmU9JTIybWlkZGxlJTIyPvwn5O8PC90ZXh0Pjwvc3ZnPiIsCiAgICAgICJzaXplcyI6ICIxOTJ4MTkyIiwKICAgICAgInR5cGUiOiAiaW1hZ2Uvc3ZnK3htbCIsCiAgICAgICJwdXJwb3NlIjogIm1hc2thYmxlIGFueSIKICAgIH0sCiAgICB7CiAgICAgICJzcmMiOiAiZGF0YTppbWFnZS9zdmcreG1sLDxzdmcgeG1sbnM9JTIyaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmclMjIgdmlld0JveD0lMjIwIDAgMTAwIDEwMCUyMj48cmVjdCB3aWR0aD0lMjIxMDAlMjIgaGVpZ2h0PSUyMjEwMCUyMiBmaWxsPSUyMiMxMjEyMTIlMjIvPjx0ZXh0IHk9JTIyLjU1ZW0lMjIgeD0lMjI1MCUyMiBmaWxsPSUyMnJlZCUyMiBmb250LXNpemU9JTIyNzAlMjIgdGV4dC1hbmNob3I9JTIybWlkZGxlJTIyIGRvbWluYW50LWJhc2VsaW5lPSUyMm1pZGRsZSUyMj7wn5O8PC90ZXh0Pjwvc3ZnPiIsCiAgICAgICJzaXplcyI6ICI1MTJ4NTEyIiwKICAgICAgInR5cGUiOiAiaW1hZ2Uvc3ZnK3htbCIsCiAgICAgICJwdXJwb3NlIjogIm1hc2thYmxlIGFueSIKICAgIH0KICBdCn0=">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.8em%22 font-size=%2285%22>üì∫</text></svg>"><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet"><style>#loader-container{position:fixed;top:0;left:0;width:100%;height:3px;background:transparent;z-index:10001;transition:opacity .4s ease}.loader-bar{height:100%;width:30%;background:var(--accent-blue);box-shadow:0 0 10px var(--accent-blue);animation:loading-slide 2s infinite ease-in-out}@keyframes loading-slide{0%{transform:translateX(-100%)}100%{transform:translateX(400%)}}.loading-finished #loader-container{opacity:0;pointer-events:none}:root{--bg-color:#121212;--card-bg:#1e1e1e;--accent-blue:#448aff;--text-main:#ffffff;--text-muted:#888888;--channel-bg:#2a2a2a;--border-color:#333333;--nav-bg:#1a1a1a;--warning:var(--accent-blue)}body{background-color:var(--bg-color);color:var(--text-main);font-family:Inter,sans-serif;margin:0;padding:6px;padding-bottom:52px;display:flex;flex-direction:column;align-items:center;min-height:100vh;overflow-x:hidden}@keyframes blink-blue{0%{opacity:1;color:var(--accent-blue)}50%{opacity:.3;color:#fff}100%{opacity:1;color:var(--accent-blue)}}@keyframes blink-line{0%{border-color:var(--accent-blue)}50%{border-color:transparent}100%{border-color:var(--accent-blue)}}.is-live .time{animation:blink-blue 1s infinite;font-weight:800}.date-header{width:100%;box-sizing:border-box;text-align:center;margin:0 auto;padding:15px 20px;display:flex;align-items:center;justify-content:center;font-size:.7rem;font-weight:700;text-transform:uppercase;letter-spacing:1px;color:var(--accent-blue);position:sticky;top:0;background:var(--bg-color);z-index:100;box-shadow:none;left:0;right:0;}.date-number{color:var(--text-main);font-weight:400;}.date-header::after,.date-header::before{content:"";flex:1;height:1px;background:var(--accent-blue);margin:0 10px;opacity:0.5}#events-container{width:95%;max-width:500px;display:flex;flex-direction:column;gap:18px;transition:max-width .3s ease, opacity 0.3s ease, transform 0.3s ease; scroll-snap-type: y proximity; scroll-padding-top: 50px; min-height: 100vh;}.tab-transitioning{opacity: 0; transform: translateY(10px);}@media (min-width:768px){#events-container{max-width:600px}.date-header{max-width:100%}}@media (min-width:1200px){#events-container{max-width:800px;display:flex;flex-direction:column;gap:18px}.date-header{width:100%;margin:0 auto}.event-card{border-bottom:1px solid #222;padding:10px 0}.event-card:last-child, .event-card:has(+ .date-header){border-bottom:none}}.event-card{display:flex;flex-direction:column;gap:8px;padding-bottom:8px;width:100%;border-bottom:1px solid #222;transition:opacity 0.3s, filter 0.3s; scroll-snap-align: start;}.event-finished{opacity:0.5;filter:grayscale(0.2) saturate(0.9);pointer-events:none}.competicion-title{color:var(--accent-blue);font-size:.65rem;font-weight:600;display:flex;align-items:center;gap:4px}.competicion-title::before{content: "";font-size:.55rem}.event-info{display:flex;align-items:center;font-size:.75rem;font-weight:500;margin-bottom:2px}.time{font-size:.6rem;color:#fff;margin-right:5px;white-space:nowrap}.time-separator{color:var(--accent-blue);margin-right:6px;font-weight:700}.vs-container{display:flex;align-items:center;gap:6px;flex-wrap:wrap;row-gap:4px;justify-content:space-between}.team-group{display:flex;align-items:center;gap:6px;white-space:nowrap}.team-group:last-child{margin-left:auto}.vs-text{color:var(--accent-blue);font-size:.55rem;font-weight:800;margin:0 1px}.team-logo{width:24px;height:24px;object-fit:contain;}.channels-wrapper{display:flex;flex-direction:row;overflow-x:auto;gap:12px;margin-top:6px;padding:4px 2px 12px 2px;scrollbar-width:none;scroll-snap-type:x mandatory;-webkit-overflow-scrolling:touch}.channels-wrapper::-webkit-scrollbar{height:4px}.channels-wrapper::-webkit-scrollbar-thumb{background:var(--accent-blue);border-radius:10px}.channel-button{position:relative;background:var(--channel-bg);color:var(--text-main);border-radius:10px;text-align:center;font-size:.65rem;font-weight:600;border:1px solid var(--border-color);display:flex;align-items:center;justify-content:center;flex:0 0 140px;height:78.75px;scroll-snap-align:start;overflow:hidden;padding:8px;cursor:pointer;transition:all .2s cubic-bezier(.4,0,.2,1);box-shadow:0 4px 6px rgba(0,0,0,.3)}.channel-button:active{transform:scale(.95)}.channel-logo{width:80%;height:80%;object-fit:contain}.btn-plus{position:absolute;bottom:0;right:0;width:40px;height:40px;background:transparent;color:transparent;display:flex;align-items:center;justify-content:center;z-index:10;cursor:pointer}.modal-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.85);display:none;justify-content:center;align-items:center;z-index:2000}.modal-content{background:var(--card-bg);width:85%;max-width:280px;max-height:80vh;overflow-y:auto;border-radius:12px;padding:15px;border:1px solid var(--border-color)}.modal-title{margin-bottom:12px;font-size:.8rem;font-weight:700;text-align:center;color:var(--accent-blue)}.id-item{background:var(--channel-bg);padding:10px;margin-bottom:8px;border-radius:8px;font-size:.7rem;text-align:center;border:1px solid var(--border-color);cursor:pointer;display:flex;justify-content:space-between;align-items:center}.id-rating{color:var(--accent-blue);font-weight:700}.bottom-nav{position:fixed;bottom:0;left:0;right:0;height:48px;background:var(--nav-bg);border-top:1px solid var(--border-color);display:flex;justify-content:space-around;align-items:center;z-index:1000}.nav-item{display:flex;flex-direction:column;align-items:center;color:var(--text-muted);text-decoration:none;font-size:.55rem;font-weight:600;gap:2px;flex:1;cursor:pointer}        .nav-item.active{color:var(--accent-blue)}.nav-icon{font-size:1rem}#status{position:fixed;top:50%;left:50%;transform:translate(-50%, -50%);z-index:10000;display:flex;align-items:center;justify-content:center}.spinner{width:48px;height:48px;border:5px solid color-mix(in srgb, var(--accent-blue) 20%, transparent);border-top:5px solid var(--accent-blue);border-radius:50%;animation:spin 1s linear infinite}@keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}/* Correcci√≥n: El modo b√∫squeda ahora respeta el layout global */
        #events-container.search-mode-active {
            padding: 0 10px;
        }

        #events-container.search-mode-active .event-card {
            width: 100%;
        }
        </style></head><body>
    <div id="loader-container">
        <div class="loader-bar"></div>
    </div><div id="status"><div class="spinner"></div></div><div id="searchContainer" style="display:none;width:95%;max-width:500px;margin:10px auto 0 auto;gap:8px;align-items:center;padding-bottom:10px;"><div style="position:relative;flex:1;display:flex;align-items:center"><input type="text" id="globalSearchInput" placeholder="Buscar canal, equipo o competici√≥n..." style="width:100%;padding:12px 40px 12px 16px;border-radius:12px;border:1px solid var(--border-color);background:var(--card-bg);color:#fff;font-size:.9rem;outline:0"><span id="clearSearch" style="position:absolute;right:12px;color:var(--text-muted);cursor:pointer;display:none;font-size:1.2rem;user-select:none">&times;</span></div></div><div id="events-container"></div>
<div id="noResultsContainer" style="display:none;text-align:center;padding:40px;color:var(--text-muted)"><div><div style="font-size:3rem;margin-bottom:10px">üì°</div><div style="font-weight:700;font-size:1.1rem;color:var(--text-main)">Sin resultados</div><div style="font-size:.85rem;margin-top:5px;opacity:.8">Intenta con otra b√∫squeda</div></div></div><div id="ids-modal" class="modal-overlay" onclick="UIManager.closeModal(event)"><div class="modal-content" onclick="event.stopPropagation()"><div id="modal-title" class="modal-title">Canales</div><div id="ids-list" class="ids-list"></div></div></div><nav class="bottom-nav"><div class="nav-item active" id="nav-home" onclick='UIManager.switchTab("home")'><span class="nav-icon">üóìÔ∏è</span><span>EVENTOS</span></div><div class="nav-item" id="nav-channels" onclick='UIManager.switchTab("channels")'><span class="nav-icon">üîç</span><span>BUSCAR</span></div></nav><script>const CONFIG = {
            BASE_URL: 'https://www.futbolenlatv.es',
            TARGET_URL: 'https://www.futbolenlatv.es/deporte',
            GIST_LOGOS: 'https://gist.githubusercontent.com/Ciento20/f7847e86d06e5011706fa76f2dab90be/raw/',
            PROXIES: [
                'https://api.allorigins.win/raw?url=',
                'https://api.codetabs.com/v1/proxy/?quest=',
                'https://corsproxy.io/?'
            ]
        };

        const STORAGE_CONFIG = {
            CACHE_KEY: 'ace_ids_cache',
            EXPIRATION_MS: 30 * 24 * 60 * 60 * 1000 // 30 d√≠as
        };        const RatingEngine = {
            DB_KEY: 'ace_autorating_v1',
            SESSION_KEY: 'ace_current_session',
            PENDING_KEY: 'ace_pending_penalties_list', // Cambiado a lista para m√∫ltiples fallos
            interval: null,

            getDB() { return JSON.parse(localStorage.getItem(this.DB_KEY)) || {}; },
            getScore(id) { return this.getDB()[id] || 3.0; },            saveScore(id, delta) {
                if (delta < 0) return; // Ignorar penalizaciones por zapping
                const db = this.getDB();
                db[id] = Math.max(1.0, Math.min(5.0, (db[id] || 3.0) + delta));
                localStorage.setItem(this.DB_KEY, JSON.stringify(db));
            },

            trackStart(id, channelName, index = 0) {
                // 1. Antes de iniciar, comprobamos si la sesi√≥n anterior fue un 'fracaso' (zapping)
                this.checkPreviousSession();
                
                const now = Date.now();
                this.stopRealTimeUpdate();
                
                const sessionData = {
                    id: id, 
                    channelName: channelName, 
                    index: index,
                    start: now, 
                    lastProcessedMin: 0
                };
                
                localStorage.setItem(this.SESSION_KEY, JSON.stringify(sessionData));
                this.startRealTimeUpdate();
            },            processFocusReturn(newChannelName) {
                localStorage.removeItem(this.PENDING_KEY); // Resetear sin penalizar al volver
            },

            checkPreviousSession() {
                const session = JSON.parse(localStorage.getItem(this.SESSION_KEY));
                if (!session) return;
                
                const durationSec = (Date.now() - session.start) / 1000;
                
                // Si el canal dur√≥ menos de 90 segundos, es un fallo de estabilidad/zapping
                if (durationSec < 90) {
                    const db = this.getDB();
                    // Penalizamos directamente el ID que acaba de fallar
                    db[session.id] = Math.max(1.0, (db[session.id] || 3.0) - 0.5);
                    localStorage.setItem(this.DB_KEY, JSON.stringify(db));
                    
                    // Guardamos en pendientes para que la UI lo marque visualmente de inmediato
                    localStorage.setItem(this.PENDING_KEY, JSON.stringify({
                        id: session.id,
                        timestamp: Date.now()
                    }));
                } else {
                    // Si dur√≥ suficiente, limpiamos marcas de error previas
                    localStorage.removeItem(this.PENDING_KEY);
                }
            },            startRealTimeUpdate() {
                if (this.interval) clearInterval(this.interval);
                this.interval = setInterval(() => {
                    const session = JSON.parse(localStorage.getItem(this.SESSION_KEY));
                    if (!session) return this.stopRealTimeUpdate();
                    const min = (Date.now() - session.start) / 60000;
                    let delta = 0;
                    if (min >= 30 && (min - session.lastProcessedMin) >= 30) {
                        delta = 1.0;
                    }

                    if (delta > 0) {
                        this.saveScore(session.id, delta);
                        session.lastProcessedMin = Math.floor(min / 30) * 30;
                        localStorage.setItem(this.SESSION_KEY, JSON.stringify(session));
                    }
                }, 30000);
            },

            stopRealTimeUpdate() { if (this.interval) clearInterval(this.interval); }
        };

        const cleanChannelName = (name) => {
            if (!name) return "";
            let rawUpper = name.toUpperCase();
            if (rawUpper.includes("ACB EVENTO 01")) name = "DAZN BALONCESTO";
            if (rawUpper.includes("ACB EVENTO 02")) name = "DAZN BALONCESTO 2";
            if (rawUpper.includes("M. DEPORTES")) name = "M+ DEPORTES";
            let cleaned = name.toUpperCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
            if (cleaned.includes("LIGA DE CAMPEONES") && !cleaned.includes("M+")) {
                cleaned = cleaned.replace("LIGA DE CAMPEONES", "M+ LIGA DE CAMPEONES");
            }
            cleaned = cleaned.replace(/PLUS\+/g, "PLUS").replace(/\bMOVISTAR\b/g, "M+").replace(/\bM\./g, "M+").replace(/\(ES\)/gi, "").replace(/\bLA LIGA\b/g, "LALIGA").replace(/\bHYPERMOTION\b/g, "LALIGA TV HYPERMOTION").replace(/\bBAR\b/gi, "").replace(/\b(HD|FHD|4K|1080P|720P)\b/gi, "").replace(/\*/g, "").replace(/\s+/g, " ").trim();
            if (cleaned.includes("CALCIO EVENTOS")) { cleaned = cleaned.replace("CALCIO EVENTOS", "SKY SPORTS CALCIO EVENTOS"); }
            if (cleaned.includes("(1RFEF) (SOLO EVENTOS)")) { cleaned = "PRIMERA FEDERACION"; }
            if (cleaned.includes("DAZN LALIGA")) {
                cleaned = cleaned.replace(/\b1\b/g, "");
            }
            if (cleaned.includes("HYPERMOTION 2")) {
                cleaned = "LALIGA TV HYPERMOTION 2";
            } else if (cleaned.includes("HYPERMOTION 3")) {
                cleaned = "LALIGA TV HYPERMOTION 3";
            } else if (cleaned.includes("HYPERMOTION 4")) {
                cleaned = "LALIGA TV HYPERMOTION 4";
            } else if (cleaned.includes("HYPERMOTION")) {
                cleaned = "LALIGA TV HYPERMOTION";
            }
            return cleaned.replace(/\s+/g, " ").trim();
        };

        const ComparisonEngine = {
            isMatch(nameA, nameB) {
                return cleanChannelName(nameA) === cleanChannelName(nameB);
            },
            normalizeText(text) {
                return text.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").trim();
            }
        };

        let channelLogosMap = JSON.parse(localStorage.getItem('logo_cache')) || {};
        let globalData = JSON.parse(localStorage.getItem('event_data_cache')) || [];
        let aceStreamMap = []; 
        let currentTab = localStorage.getItem('active_tab') || 'home';
        const state = { tvSearchTerm: localStorage.getItem('search_query') || '' };

        const NetworkService = {
            async fetchHtml(targetUrl) {
                const fetchPromises = CONFIG.PROXIES.map(proxy => 
                    fetch(`${proxy}${encodeURIComponent(targetUrl)}`)
                        .then(res => { if (!res.ok) throw new Error(); return res.text(); })
                );
                try { return await Promise.any(fetchPromises); } 
                catch (e) { throw new Error("Error de conexi√≥n"); }
            },
            async fetchLogos() {
                try {
                    const response = await fetch(CONFIG.GIST_LOGOS);
                    const text = await response.text();
                    const map = {};
                    text.split('\n').forEach(line => {
                        if (line.includes(': http')) {
                            const parts = line.split(': http');
                            const rawName = parts[0].trim();
                            map[cleanChannelName(rawName)] = 'http' + parts[1].trim();
                        }
                    });
                    return map;
                } catch (e) { return {}; }
            }
        };

        const AceStreamEngine = {
            SOURCES: [
                { id: 'ERA', url: 'https://ipfs.io/ipns/k2k4r8oqlcjxsritt5mczkcn4mmvcmymbqw7113fz2flkrerfwfps004/data/listas/listaplana.txt', parser: 'parseEra' },
                { id: 'ELCANO', url: 'https://acestream-ids.vercel.app/', parser: 'parseElcano' }
            ],generateHash(str){let hash=5381,i=str.length;while(i)hash=(hash*33)^str.charCodeAt(--i);return(hash>>>0).toString(16)},

            async init() {
                let masterMap = new Map();
                const cache = JSON.parse(localStorage.getItem(STORAGE_CONFIG.CACHE_KEY)) || { hashes: {}, data: [] };
                const currentHashes = cache.hashes || {};
                let hasChanges = false;cache.data.forEach(item => masterMap.set(item.id, item));

                for (const src of this.SOURCES) {
                    try {
                        const raw = await NetworkService.fetchHtml(src.url);
                        const newHash = this.generateHash(raw);if (currentHashes[src.id] === newHash) continue;
                        hasChanges = true;
                        currentHashes[src.id] = newHash;
                        
                        const parsed = src.parser === 'parseEra' ? this.parseEra(raw) : this.parseElcano(raw);
                        parsed.forEach(item => {
                            item.source = src.id === 'ELCANO' ? 'ELC' : 'ERA';
                            masterMap.set(item.id, item);
                        });} catch (e) {}
                }

                const master = Array.from(masterMap.values());

                if (hasChanges && master.length > 0) {
                    this.saveToCache(master, currentHashes);
                } else if (master.length === 0) {
                    return this.loadFromCache();
                }
                return master;
            },            saveToCache(data, hashes = {}) {
                const cacheObj = { 
                    timestamp: Date.now(), 
                    data: data, 
                    hashes: hashes 
                };
                localStorage.setItem(STORAGE_CONFIG.CACHE_KEY, JSON.stringify(cacheObj));
            },
            loadFromCache() {
                const cached = localStorage.getItem(STORAGE_CONFIG.CACHE_KEY);
                if (!cached) return [];
                try {
                    const cacheObj = JSON.parse(cached);
                    const isExpired = (Date.now() - cacheObj.timestamp) > STORAGE_CONFIG.EXPIRATION_MS;
                    return isExpired ? [] : (cacheObj.data || []);
                } catch (e) { return []; }
            },
            parseEra(text) {
                const results = [];
                const lines = text.split('\n').filter(l => l.trim());
                for (let i = 0; i < lines.length; i += 2) {
                    let name = lines[i].split('-->')[0].trim();
                    // Limpieza de sufijos de calidad espec√≠ficos de ERA
                    name = name.replace(/\b(HDP|SDP|FHDP)\b/gi, '').trim();
                    const id = lines[i+1]?.trim().replace(/p$/, '');
                    if (id && id.length === 40) results.push({ name, id });
                }
                return results;
            },
            parseElcano(html) {
                const jsonMatch = html.match(/const links\s*=\s*(\[[\s\S]*?\]);/);
                if (!jsonMatch) return [];
                try {
                    return JSON.parse(jsonMatch[1])
                        .filter(l => l.url.includes('acestream://'))
                        .map(l => ({ 
                            name: l.name.trim(), 
                            id: l.url.split('://')[1] 
                        }));
                } catch (e) { return []; }
            }
        };        const LiveEngine = {
            checkLive(event) {
                const fechaLimpia = event.fecha.toLowerCase();
                if (!fechaLimpia.includes("hoy") && !fechaLimpia.includes("directo")) return false;
                
                const now = new Date();
                const [hrs, mins] = event.hora.split(':').map(Number);
                const startTime = new Date();
                startTime.setHours(hrs, mins, 0, 0);

                // Extraemos todo el texto (competici√≥n + detalles del evento como "Libres" o "Carrera")
                const searchPool = (event.competition + ' ' + event.infoHtml.replace(/<[^>]*>?/gm, '')).toUpperCase();

                // JERARQU√çA DE TIEMPOS CONCRETOS
                const specificDurations = [
                    // F√ìRMULA 1
                    { key: 'F√ìRMULA 1', sub: 'LIBRES', duration: 75 },
                    { key: 'F√ìRMULA 1', sub: 'CLASIFICACI√ìN', duration: 85 },
                    { key: 'F√ìRMULA 1', sub: 'SPRINT', duration: 65 },
                    { key: 'F√ìRMULA 1', sub: 'CARRERA', duration: 145 },
                    { key: 'F√ìRMULA 1', duration: 130 }, // Gen√©rico F1

                    // MOTOGP
                    { key: 'MOTOGP', sub: 'LIBRES', duration: 65 },
                    { key: 'MOTOGP', sub: 'CLASIFICACI√ìN', duration: 70 },
                    { key: 'MOTOGP', sub: 'SPRINT', duration: 55 },
                    { key: 'MOTOGP', sub: 'CARRERA', duration: 85 },
                    { key: 'MOTOGP', duration: 80 },

                    // F√öTBOL (Ligas y Copas)
                    { key: 'CHAMPIONS LEAGUE', duration: 140 },
                    { key: 'EUROPA LEAGUE', duration: 140 },
                    { key: 'COPA DEL REY', duration: 155 },
                    { key: 'LALIGA', duration: 115 },
                    { key: 'PREMIER LEAGUE', duration: 115 },
                    
                    // BALONCESTO
                    { key: 'NBA', duration: 165 },
                    { key: 'EUROLIGA', duration: 135 },
                    { key: 'ACB', duration: 130 },

                    // TENIS
                    { key: 'WIMBLEDON', duration: 260 },
                    { key: 'ROLAND GARROS', duration: 260 },
                    { key: 'ATP 1000', duration: 165 },
                    { key: 'ATP', duration: 145 },

                    // OTROS
                    { key: 'UFC', duration: 240 },
                    { key: 'NFL', duration: 210 }
                ];

                // Tiempos por defecto seg√∫n el icono si no hay coincidencia espec√≠fica
                const sportDefaults = {
                    '‚öΩ': 115, 'üèÄ': 130, 'üéæ': 150, 'üèéÔ∏è': 120, 
                    'üèçÔ∏è': 70, 'üö¥': 240, 'üëä': 180, 'ü§æ': 95
                };

                let duration = 120;

                // L√≥gica de detecci√≥n: busca primero la combinaci√≥n (F1 + Libres) 
                const match = specificDurations.find(d => {
                    const hasKey = searchPool.includes(d.key);
                    const hasSub = !d.sub || searchPool.includes(d.sub);
                    return hasKey && hasSub;
                });

                if (match) {
                    duration = match.duration;
                } else {
                    const emoji = event.competition.split(' ')[0];
                    duration = sportDefaults[emoji] || 120;
                }

                const endTime = new Date(startTime.getTime() + duration * 60000);
                return now >= startTime && now <= endTime;
            }
        };

        const DataParser = {
            fixUrl(url) {
                if (!url || url.startsWith('http')) return url;
                return CONFIG.BASE_URL + (url.startsWith('/') ? '' : '/') + url;
            },
            parse(html) {
                const doc = new DOMParser().parseFromString(html, 'text/html');
                const rows = doc.querySelectorAll('.tablaPrincipal tr');
                const results = [];
                let currentFecha = "";

                rows.forEach(row => {
                    if (row.classList.contains('cabeceraTabla')) {
                        const rawFecha = row.textContent.trim().toUpperCase().replace(/PARTIDOS/gi, 'EVENTOS');
                    currentFecha = rawFecha.replace(/,/g, ' &nbsp; ').replace(/(\d+)/g, '<span class="date-number">$1</span>')
                                           .replace(/\b(EVENTOS|DE|HOY|MA√ëANA)\b/g, '<span style="color:var(--text-main); margin-right: 4px;">$1</span>')
                                           .replace(/<\/span>\s+<span/g, '</span>&nbsp;<span');
                        return;
                    }
                    const hora = row.querySelector('.hora')?.textContent.trim();
                    if (!hora) return;

                    const compElem = row.querySelector('.detalles .ajusteDoslineas') || row.querySelector('.detalles label');
                    let competition = compElem?.title || compElem?.textContent || "Competici√≥n";
                    const sportImg = row.querySelector('.contenedorImgCompeticion img');
                    const sportName = (sportImg?.getAttribute('alt') || sportImg?.getAttribute('title') || '').toUpperCase();
                    
                    const emojiMap = {
                        'F√öTBOL': '‚öΩ', 'F√öTBOL SALA': 'üåï', 
                        'BALONCESTO': 'üèÄ', 'BASKETBALL': 'üèÄ', 
                        'TENIS': 'üéæ', 'TENNIS': 'üéæ',
                        'AUTOMOVILISMO': 'üèÅ', 'F√ìRMULA 1': 'üèéÔ∏è', 'FORMULA 1': 'üèéÔ∏è', 'MOTOCICLISMO': 'üèçÔ∏è',
                        'CICLISMO': 'üö¥', 
                        'GOLF': '‚õ≥', 
                        'BALONMANO': 'ü§æ', 
                        'UFC': 'üëä', 'BOXEO': 'ü•ä', 'MMA': 'üëä',
                        'HOCKEY': 'üèí',
                        'RUGBY U': 'üèâ'
                    };
                    window.GLOBAL_EMOJI_MAP = emojiMap;

                    let emoji = "üèÜ";
                    for (const [key, icon] of Object.entries(emojiMap)) {
                        if (sportName.includes(key)) {
                            emoji = icon;
                            break;
                        }
                    }
                    competition = emoji + " " + competition;
                    const canales = Array.from(row.querySelectorAll('.listaCanales li'))
                        .map(ch => ch.textContent.trim().split('(')[0].trim());

                    const local = row.querySelector('.local span');
                    const visitante = row.querySelector('.visitante span');
                    const localImg = row.querySelector('.local img');
                    const visitanteImg = row.querySelector('.visitante img');
                    const eventoUnico = row.querySelector('.eventoUnico');

                    let infoHtml = "";
                    if (local && visitante) {
                        infoHtml = `
                            <div class="vs-container">
                                <div class="team-group">
                                    <img src="${this.fixUrl(localImg?.src)}" class="team-logo" onerror="this.style.display='none'">
                                    <span>${local.title || local.textContent}</span>
                                    <span class="vs-text">VS</span>
                                </div>
                                <div class="team-group">
                                    <span>${visitante.title || visitante.textContent}</span>
                                    <img src="${this.fixUrl(visitanteImg?.src)}" class="team-logo" onerror="this.style.display='none'">
                                </div>
                            </div>`;
                    } else if (eventoUnico) {
                        infoHtml = `<div class="vs-container"><span>${eventoUnico.innerText.trim()}</span></div>`;
                    }

                    results.push({ fecha: currentFecha, hora, competition, infoHtml, canales });
                });
                return results;
            }
        };

        const UIManager = {
            container: document.getElementById('events-container'),
            status: document.getElementById('status'),
            modal: document.getElementById('ids-modal'),
            lastClickTime: 0,

            switchTab(tab) {
                if (tab === 'home') {
                    const now = Date.now();
                    if (now - this.lastClickTime < 1000) {
                        this.setRandomColor();
                        this.lastClickTime = 0;
                        return;
                    }
                    this.lastClickTime = now;
                }
                currentTab = tab;
                localStorage.setItem('active_tab', tab);
                const searchContainer = document.getElementById('searchContainer');
                
                document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
                document.getElementById(`nav-${tab}`).classList.add('active');                if (tab === 'channels') {
                    searchContainer.style.display = 'flex';
                    this.container.classList.add('search-mode-active');
                    document.getElementById('globalSearchInput').focus();
                } else {
                    searchContainer.style.display = 'none';
                    this.container.classList.remove('search-mode-active');
                    if (tab !== 'channels') {
                        state.tvSearchTerm = '';
                        localStorage.removeItem('search_query');
                        document.getElementById('globalSearchInput').value = '';
                    }
                    const noResults = document.getElementById('noResultsContainer');
                    if (noResults) noResults.style.display = 'none';
                }

                this.refresh();
                window.scrollTo(0,0);
            },            lastEventsHTML: '',            refresh() {
                globalData.forEach(item => { item.isLive = LiveEngine.checkLive(item); });
                const processed = [...globalData].sort((a, b) => (a.isLive === b.isLive) ? 0 : a.isLive ? -1 : 1);
                
                if (currentTab === 'home') {
                    if (state.tvSearchTerm === '' && this.lastEventsHTML) {
                        if (this.container.innerHTML !== this.lastEventsHTML) {
                            this.container.innerHTML = this.lastEventsHTML;
                        }
                    } else {
                        this.renderEvents(processed);
                    }
                } else {
                    this.renderUniqueChannels(processed);
                }
            },            renderEvents(data) {
                const noResults = document.getElementById('noResultsContainer');
                if (noResults) noResults.style.display = 'none';

                const renderedList = data.map(item => {
                    const availableChannels = [];
                    const seen = new Set();
                    item.canales.forEach(c => {
                        if (aceStreamMap.some(a => ComparisonEngine.isMatch(c, a.name))) {
                            const clean = cleanChannelName(c);
                            if (!seen.has(clean)) {
                                seen.add(clean);
                                availableChannels.push(c);
                            }
                        }
                    });
                    return { ...item, availableChannels };
                }).filter(i => i.availableChannels.length > 0);

                let lastFinishedIdx = -1;
                let lastLiveIdx = -1;
                const now = new Date();
                renderedList.forEach((item, idx) => {
                    if (item.isLive) lastLiveIdx = idx;
                    const [h, m] = item.hora.split(':').map(Number);
                    const eventTime = new Date(); eventTime.setHours(h, m, 0, 0);
                    if (!item.isLive && now > eventTime && item.fecha.toUpperCase().includes('HOY')) {
                        lastFinishedIdx = idx;
                    }
                });

                let htmlBuffer = "";
                let lastDate = "";
                renderedList.forEach((item, idx) => {
                    if (item.fecha !== lastDate) {
                        htmlBuffer += `<div class="date-header">${item.fecha}</div>`;
                        lastDate = item.fecha;
                    }
                    const isLastFinished = idx === lastFinishedIdx;
                    const isLastLive = idx === lastLiveIdx;
                    const [h, m] = item.hora.split(':').map(Number);
                    const evTime = new Date(); evTime.setHours(h, m, 0, 0);
                    const isPast = !item.isLive && (new Date() > evTime) && item.fecha.toUpperCase().includes('HOY');
                    let extraStyle = '';
                    if (isLastLive) extraStyle = 'border-bottom: 2px solid rgba(255,255,255,0.2); margin-bottom: 12px; padding-bottom: 12px;';                    if (isLastFinished) {
                        extraStyle = 'margin-bottom: 0px; padding-bottom: 12px;';
                    }
                    htmlBuffer += `
                        <div class="event-card ${item.isLive ? 'is-live' : ''} ${isPast ? 'event-finished' : ''}" style="${extraStyle}">
                            <div class="competicion-title">${item.competition}</div>
                            <div class="event-info"><span class="time">${item.hora}</span><span class="time-separator">|</span>${item.infoHtml}</div>
                            <div class="channels-wrapper">${item.availableChannels.map(c => this.getChannelHtml(c)).join('')}</div>
                        </div>
                    `;
                    if (isLastFinished) {
                        const now = new Date();
                        const timeStr = now.getHours().toString().padStart(2, '0') + ':' + now.getMinutes().toString().padStart(2, '0');                        htmlBuffer += `<div class="date-header" style="position:static; background:transparent; margin:10px 0; animation: blink-marker 2s infinite; z-index:1;"><span class="date-number" id="real-time-marker" style="margin:0">${timeStr}</span></div><style>@keyframes blink-marker{0%,100%{opacity:1}50%{opacity:0.2}}</style>`;
                    }
                });
                this.container.innerHTML = htmlBuffer;
                if (state.tvSearchTerm === '') this.lastEventsHTML = htmlBuffer;
            },            renderUniqueChannels(data) {
                const input = document.getElementById('globalSearchInput');
                const selectionStart = input.selectionStart;
                const selectionEnd = input.selectionEnd;
                const searchTerm = state.tvSearchTerm;
                this.container.innerHTML = "";

                if (searchTerm) {
                    const matchedEvents = data.filter(event => {
                        const sportNames = window.GLOBAL_EMOJI_MAP ? Object.keys(window.GLOBAL_EMOJI_MAP).join(' ') : '';
                    const eventSport = window.GLOBAL_EMOJI_MAP ? (Object.keys(window.GLOBAL_EMOJI_MAP).find(s => event.competition.includes(window.GLOBAL_EMOJI_MAP[s])) || '') : '';
                    const textToSearch = ComparisonEngine.normalizeText(event.competition + event.infoHtml + ' ' + eventSport);
                        return textToSearch.includes(searchTerm);
                    });

                    if (matchedEvents.length > 0) {
                        this.renderEvents(matchedEvents);
                        const divider = document.createElement('div');
                        divider.style.cssText = "width:100%; height:1px; background:#333; margin:20px 0; grid-column: 1/-1;";
                        this.container.appendChild(divider);
                    }
                }

                const uniqueMap = new Map();
                const filteredAceStreams = aceStreamMap.filter(ace => {
                    if (!searchTerm) return true;
                    return ComparisonEngine.normalizeText(ace.name).includes(searchTerm);
                });

                filteredAceStreams.forEach(item => {
                    const clean = cleanChannelName(item.name);
                    if (!uniqueMap.has(clean)) uniqueMap.set(clean, item.name);
                });

                const noResults = document.getElementById('noResultsContainer');
                if (uniqueMap.size === 0 && this.container.children.length === 0) {
                    if (noResults) noResults.style.display = 'block';
                    return;
                } else {
                    if (noResults) noResults.style.display = 'none';
                }

                input.focus();
                input.setSelectionRange(selectionStart, selectionEnd);                const getPriority = (name) => {
                    const n = cleanChannelName(name).toUpperCase();
                    // Excluir canales internacionales de la prioridad alta
                    const isForeign = n.includes('(PL)') || n.includes('(DE)') || n.includes('(RU)');

                    if (n.includes('ELEVEN') || isForeign) return 4.1;
                    if (n.includes('DAZN')) return 1;
                    if (n.includes('M+') || n.includes('MOVISTAR') || n.includes('LIGA DE CAMPEONES') || n.includes('HYPERMOTION')) return 2;
                    if (n.includes('EUROSPORT')) return 3;
                    
                    return 4.1;
                };                const gistOrder = Object.keys(channelLogosMap);
                const sortedChannels = Array.from(uniqueMap.values()).sort((a, b) => {
                    const pA = getPriority(a), pB = getPriority(b);
                    if (pA !== pB) return pA - pB;
                    
                    const indexA = gistOrder.indexOf(cleanChannelName(a));
                    const indexB = gistOrder.indexOf(cleanChannelName(b));
                    
                    if (indexA !== -1 && indexB !== -1) return indexA - indexB;
                    if (indexA !== -1) return -1;
                    if (indexB !== -1) return 1;
                    
                    return cleanChannelName(a).localeCompare(cleanChannelName(b));
                });

                const groups = { DAZN: [], MOVISTAR: [], EUROSPORT: [], OTROS: [] };
                sortedChannels.forEach(name => {
                    const p = getPriority(name);
                    if (p === 1) groups.DAZN.push(name);
                    else if (p === 2) groups.MOVISTAR.push(name);
                    else if (p === 3) groups.EUROSPORT.push(name);
                    else groups.OTROS.push(name);
                });

                const renderGroup = (title, channels, color, logoKey, isEurosport = false) => {
    if (channels.length === 0) return '';
    const logoUrl = channelLogosMap[cleanChannelName(logoKey)] || '';
    
    let contentHtml = '';
    if (title === 'OTROS CANALES') {
        const regions = [
            { keys: ['[US]', '(US)'], flag: 'üá∫üá∏', id: 'us' },
            { keys: ['[UK]', '(UK)'], flag: 'üá¨üáß', id: 'uk' },
            { keys: ['[BE]', '(BE)'], flag: 'üáßüá™', id: 'be' },
            { keys: ['[DE]', '(DE)'], flag: 'üá©üá™', id: 'de' },
            { keys: ['[TR]', '(TR)'], flag: 'üáπüá∑', id: 'tr' },
            { keys: ['[PL]', '(PL)'], flag: 'üáµüá±', id: 'pl' },
            { keys: ['[RU]', '(RU)'], flag: 'üá∑üá∫', id: 'ru' }
        ];

        let mainChannels = channels.filter(c => !regions.some(r => r.keys.some(k => c.toUpperCase().includes(k))));
        let regionHtml = '';        contentHtml = `<div style="display:flex; flex-wrap:wrap; gap:10px; justify-content:center;">`;
        contentHtml += mainChannels.map(c => this.getChannelHtml(c)).join('');

        regions.forEach(reg => {
            const regChannels = channels.filter(c => reg.keys.some(k => c.toUpperCase().includes(k)));
            if (regChannels.length > 0) {
                const containerId = `group-${reg.id}`;
                contentHtml += `
                    <div class="channel-button" onclick="const el = document.getElementById('${containerId}'); el.style.display = el.style.display === 'none' ? 'flex' : 'none'">
                        <span style="font-size:2rem;">${reg.flag}</span>
                    </div>
                    <div id="${containerId}" style="display:none; width:100%; flex-wrap:wrap; gap:10px; justify-content:center; margin:10px 0; padding:10px; background:rgba(255,255,255,0.05); border-radius:10px; border:1px dashed rgba(255,255,255,0.1);">
                        ${regChannels.map(c => this.getChannelHtml(c)).join('')}
                    </div>`;
            }
        });

        contentHtml += `</div>`;
    } else {
        contentHtml = `<div style="display:flex; flex-wrap:wrap; gap:10px; justify-content:center;">${channels.map(c => this.getChannelHtml(c)).join('')}</div>`;
    }

    return `<div style="width:100%; background:rgba(0,0,0,0.25); border:1px solid ${color}; border-radius:12px; padding:12px; margin-bottom:15px; box-sizing:border-box;">
        <div style="display:flex; align-items:center; gap:8px; margin-bottom:10px; padding-bottom:5px; border-bottom:1px solid ${color}33;">
            ${logoUrl ? `<img src="${logoUrl}" style="height:${isEurosport ? '24px' : '18px'}; object-fit:contain; ${title === 'DAZN' ? 'background:white; border-radius:4px; padding:2px;' : ''}">` : ''}
            <span style="color:white; font-weight:700; font-size:0.75rem; text-transform:uppercase;">${title}</span>
        </div>
        ${contentHtml}
    </div>`;
};

                this.container.innerHTML += renderGroup('DAZN', groups.DAZN, '#fffc01', 'DAZN');
                this.container.innerHTML += renderGroup('MOVISTAR+', groups.MOVISTAR, '#0165fe', 'MOVISTAR');
                this.container.innerHTML += renderGroup('EUROSPORT', groups.EUROSPORT, '#dd0452', 'EUROS', true);
                this.container.innerHTML += renderGroup('OTROS CANALES', groups.OTROS, '#333333', '');

                // Canales renderizados por grupos superiores
            },            getChannelHtml(name) {
                const clean = cleanChannelName(name);
                const logoUrl = channelLogosMap[clean];
                const matching = aceStreamMap.filter(a => ComparisonEngine.isMatch(name, a.name));
                if (matching.length === 0) return '';

                const pending = JSON.parse(localStorage.getItem(RatingEngine.PENDING_KEY));
                const bestIdObj = matching.map(item => {
                    let s = RatingEngine.getScore(item.id);
                    if (pending && pending.id === item.id) s = Math.max(1.0, s - 1.5);
                    return { ...item, effectiveScore: s };
                }).sort((a, b) => b.effectiveScore - a.effectiveScore)[0];
                const safeName = name.replace(/'/g, "\\'");
                let badgeHtml = '';
                const upperName = clean.toUpperCase();

                if (upperName.includes('BALONCESTO')) {
                    badgeHtml = '<div style="position: absolute; right: 15.4%; top: 50.5%; transform: translateY(-50%); font-size: 36.7px; line-height: 1; z-index: 0; opacity: 0.9;">üèÄ</div>';
                }

                if (upperName.includes('VAMOS 2')) {
                    badgeHtml = '<div style="position: absolute; left: 28px; bottom: 12px; color: #1ec33c; font-weight: 900; font-size: 1.5rem; z-index: 2;">2</div>';
                }

                return `<div class="channel-button" 
                             onclick="UIManager.handleChannelClick(event, '${safeName}')"
                             onmousedown="UIManager.startLongPress(event, '${safeName}')" 
                             onmouseup="UIManager.clearLongPress()" 
                             onmouseleave="UIManager.clearLongPress()"
                             ontouchstart="UIManager.startLongPress(event, '${safeName}')" 
                             ontouchmove="const moveY = Math.abs(event.touches[0].clientY - UIManager.touchStartY); if(moveY > 10) UIManager.clearLongPress();"
                             ontouchend="UIManager.clearLongPress()">
                        ${badgeHtml}
                        ${logoUrl ? `<img src="${logoUrl}" class="channel-logo" style="position:relative; z-index:2; pointer-events:none;" onerror="this.outerHTML='<span>${clean}</span>'">` : `<span style="position:relative; z-index:2; pointer-events:none;">${clean}</span>`}
                    </div>`;
            },            longPressTimer: null,
            isLongPress: false,
            touchStartY: 0,

            startLongPress(event, channelName) {
                this.isLongPress = false;
                // Guardamos la posici√≥n inicial para detectar scroll
                this.touchStartY = event.touches ? event.touches[0].clientY : event.clientY;
                
                this.longPressTimer = setTimeout(() => {
                    this.isLongPress = true;
                    this.openIdsModal(event, channelName);
                    if (navigator.vibrate) navigator.vibrate(50);
                }, 650);
            },

            clearLongPress() {
                clearTimeout(this.longPressTimer);
            },

            handleChannelClick(event, channelName) {
                if (!this.isLongPress) {
                    this.playBestOrNext(channelName);
                }
                this.isLongPress = false;
            },            playBestOrNext(channelName) {
                const matching = aceStreamMap
                    .filter(a => ComparisonEngine.isMatch(channelName, a.name))
                    .sort((a, b) => RatingEngine.getScore(b.id) - RatingEngine.getScore(a.id));

                if (matching.length === 0) return;

                const normName = ComparisonEngine.normalizeText(channelName);
                const lastIdxKey = 'last_idx_' + normName;
                const lastTimeKey = 'last_ts_' + normName;
                
                const lastIndex = parseInt(localStorage.getItem(lastIdxKey)) || 0;
                const lastTimestamp = parseInt(localStorage.getItem(lastTimeKey)) || 0;
                const now = Date.now();

                let nextIndex;
                // Si han pasado m√°s de 15 minutos (900.000 ms), reseteamos al mejor (√≠ndice 0)
                if (now - lastTimestamp > 900000) {
                    nextIndex = 0;
                } else {
                    // Si es un clic r√°pido (reintento), pasamos al siguiente
                    nextIndex = (lastIndex + 1) % matching.length;
                }
                
                localStorage.setItem(lastIdxKey, nextIndex);
                localStorage.setItem(lastTimeKey, now);
                RatingEngine.trackStart(matching[nextIndex].id, channelName, nextIndex);

                location.href = 'acestream://' + matching[nextIndex].id;
            },

            openIdsModal(event, channelName) {
                event.stopPropagation();
                const list = document.getElementById('ids-list');
                const title = document.getElementById('modal-title');
                
                const matching = aceStreamMap
                    .filter(a => ComparisonEngine.isMatch(channelName, a.name))
                    .sort((a, b) => RatingEngine.getScore(b.id) - RatingEngine.getScore(a.id));

                title.textContent = cleanChannelName(channelName);
                list.innerHTML = "";
                
                matching.forEach((item, i) => {
                    let currentRating = RatingEngine.getScore(item.id);
                    const pending = JSON.parse(localStorage.getItem(RatingEngine.PENDING_KEY));
                    if (pending && pending.id === item.id) {
                        currentRating = Math.max(1.0, currentRating - 1.5);
                    }
                    const btn = document.createElement('div');
                    btn.className = 'id-item';                    btn.innerHTML = `
                        <small style="flex: 1; text-align: left; color: var(--text-muted); font-size: 0.6rem; font-weight: 700; opacity: 0.6; letter-spacing: 0.5px;">${item.source || 'ID'}</small>
                        <span style="flex: 2; text-align: center; font-family: monospace; opacity: 0.9;">${item.id.substring(0, 10).toUpperCase()}</span>
                        <span class="id-rating" style="flex: 1; text-align: right;">‚òÖ ${currentRating.toFixed(1)}</span>
                    `;
                    btn.onclick = () => {
                        RatingEngine.trackStart(item.id, channelName, i);
                        window.location.href = `acestream://${item.id}`;
                    };
                    list.appendChild(btn);
                });
                this.modal.style.display = 'flex';
            },            closeModal() { this.modal.style.display = 'none'; },

            setRandomColor() {
                const randomColor = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
                document.documentElement.style.setProperty('--accent-blue', randomColor);
                localStorage.setItem('custom_accent_color', randomColor);
            }
        };        async function init() {
            const savedColor = localStorage.getItem('custom_accent_color');
            if (savedColor) document.documentElement.style.setProperty('--accent-blue', savedColor);

            let sT;
            const gInput = document.getElementById('globalSearchInput');
            const cBtn = document.getElementById('clearSearch');
            
            // Restaurar estado inicial de b√∫squeda e interfaz
            if (state.tvSearchTerm) {
                gInput.value = state.tvSearchTerm;
                cBtn.style.display = 'block';
            }
            UIManager.switchTab(currentTab);
            gInput.addEventListener('input', (e) => {
                cBtn.style.display = e.target.value ? 'block' : 'none';
                clearTimeout(sT);
                sT = setTimeout(() => {
                    const term = ComparisonEngine.normalizeText(e.target.value);
                    if (state.tvSearchTerm !== term) { 
                        state.tvSearchTerm = term; 
                        localStorage.setItem('search_query', term);
                        UIManager.refresh(); 
                    }
                }, 150);
            });
            cBtn.addEventListener('click', () => {
                gInput.value = '';
                state.tvSearchTerm = '';
                localStorage.removeItem('search_query');
                cBtn.style.display = 'none';
                gInput.focus();
                UIManager.refresh();
            });

            let touchstartX = 0; let touchendX = 0;
            const container = document.getElementById('events-container');            let isScrollActive = false;
            let startY = 0;

            const handleGesture = (e) => {
                if (isScrollActive) return;
                
                const swipeThreshold = 75;
                const diffX = touchendX - touchstartX;
                const diffY = Math.abs(e.changedTouches[0].screenY - startY);

                // Solo disparamos si el movimiento es horizontal y no vertical
                if (Math.abs(diffX) > swipeThreshold && Math.abs(diffX) > diffY) {
                    const newTab = (diffX > 0 && currentTab === 'channels') ? 'home' : (diffX < 0 && currentTab === 'home') ? 'channels' : null;
                    if (newTab) {
                        container.classList.add('tab-transitioning');
                        setTimeout(() => {
                            UIManager.switchTab(newTab);
                            container.classList.remove('tab-transitioning');
                        }, 300);
                    }
                }
            };            const handleTouchStart = e => {
                const wrapper = e.target.closest('.channels-wrapper');
                isScrollActive = wrapper && (wrapper.scrollWidth > wrapper.clientWidth);
                touchstartX = e.changedTouches[0].screenX;
                startY = e.changedTouches[0].screenY;
            };

            container.addEventListener('touchstart', handleTouchStart, {passive: true});
            document.getElementById('noResultsContainer').addEventListener('touchstart', handleTouchStart, {passive: true});            const handleTouchEnd = e => {
                touchendX = e.changedTouches[0].screenX;
                
                handleGesture(e);
            };            container.addEventListener('touchend', handleTouchEnd, {passive: true});
            document.getElementById('noResultsContainer').addEventListener('touchend', handleTouchEnd, {passive: true});

            window.addEventListener('focus', () => RatingEngine.checkPreviousSession());
            aceStreamMap = AceStreamEngine.loadFromCache();
            if (globalData.length > 0 || aceStreamMap.length > 0) {
                UIManager.refresh();
                UIManager.status.style.display = 'none';
            }
            try {
                const [logos, html] = await Promise.all([
                    NetworkService.fetchLogos(), 
                    NetworkService.fetchHtml(CONFIG.TARGET_URL)
                ]);
                if (logos && Object.keys(logos).length > 0) {
                    channelLogosMap = logos;
                    localStorage.setItem('logo_cache', JSON.stringify(logos));
                }                const freshData = DataParser.parse(html);
                if (freshData && freshData.length > 0) {
                    globalData = []; // Limpiamos cach√© de eventos para evitar acumulaci√≥n
                    globalData = freshData;
                    localStorage.setItem('event_data_cache', JSON.stringify(freshData));
                }
                aceStreamMap = await AceStreamEngine.init();
                UIManager.refresh();
                
                // Sincronizaci√≥n manejada por el Master Clock al final del script
                UIManager.status.style.display = 'none';
                document.body.classList.add('loading-finished');} catch (err) {
                document.body.classList.add('loading-finished');
                if (globalData.length === 0) {
                    UIManager.status.style.display = 'block';
                    UIManager.status.textContent = "Error de red. Usando cach√©.";
                }
            }
        }        init();

        window.syncMarker = () => {
            const marker = document.getElementById('real-time-marker');
            const now = new Date();
            const timeStr = now.getHours().toString().padStart(2, '0') + ':' + now.getMinutes().toString().padStart(2, '0');
            if (marker) {
                marker.textContent = timeStr;
            }
            return timeStr;
        };

        const startMasterClock = () => {
            const forceUpdate = () => {
                // 1. Actualizar la l√≥gica de datos
                if (typeof UIManager !== 'undefined') {
                    UIManager.lastEventsHTML = ''; // Forzar regeneraci√≥n de HTML
                    UIManager.refresh();
                }
                // 2. Actualizar el reloj visual inmediatamente
                const timeStr = window.syncMarker();
                console.log('Update ejecutado a las: ' + timeStr);
            };

            // Ejecutar cada vez que cambia el minuto exacto
            const scheduleNext = () => {
                const now = new Date();
                const msUntilNextMinute = (60 - now.getSeconds()) * 1000 - now.getMilliseconds();
                
                setTimeout(() => {
                    forceUpdate();
                    scheduleNext(); // Re-programar para el siguiente minuto exacto
                }, msUntilNextMinute);
            };

            scheduleNext();
            // Ejecuci√≥n inmediata al cargar para asegurar que el reloj no espere al primer minuto
            window.syncMarker();
        };
        startMasterClock();

        // L√≥gica de autorefresco a las 00:00:03
        const scheduleMidnightRefresh = () => {
            const now = new Date();
            const midnight = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 0, 0, 5);
            const msUntilRefresh = midnight.getTime() - now.getTime();
            
            setTimeout(() => {
                localStorage.removeItem('event_data_cache');
                location.reload();
            }, msUntilRefresh);
        };
        
        const checkDateChange = () => {
            const today = new Date().toDateString();
            const lastDate = localStorage.getItem('last_visit_date');
            if (lastDate && lastDate !== today) {
                localStorage.removeItem('event_data_cache');
            }
            localStorage.setItem('last_visit_date', today);
        };

        checkDateChange();
        scheduleMidnightRefresh();
        </script></body></html>