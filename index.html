<!doctype html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.6,user-scalable=no">
    <title>TV</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.8em%22 font-size=%2285%22>üì∫</text></svg>">
    <style>
        :root {
            --primary: #2563eb;
            --primary-light: rgba(37, 99, 235, 0.1);
            --primary-dark: #1e50c7;
            --bg-light: #f1f5f9;
            --card-bg: #ffffff;
            --text: #1e293b;
            --border-color: #e2e8f0;
            --white: #ffffff;
            --radius-md: 5px;
            --radius-sm: 3px;
            --shadow-sm: 0 0.5px 1.5px rgba(0, 0, 0, 0.1);
            --primary-rgb: 37, 99, 235;
            --secondary: #000000;
            --success: #4cc9f0;
            --warning: #f8961e;
            --info: #4895ef;
            --gist-source-color: #2d077d;
            --elcano-source-color: #7d070e;
            --special-gist-color: #9c27b0;
            --events-source-color: #074f7d;
            --shickat-badge: #077b3b;
            --era-source-color: #f55d3e;
            --channel-name-color: #888888;
            --player-bg: black;
            --channel-number-color: #4b5563
        }

        body.dark-mode {
            --bg-light: #f1f5f9;
            --card-bg: #ffffff;
            --text: #1e293b;
            --border-color: #383838;
            --shadow-sm: 0 0.5px 1.5px rgba(0, 0, 0, 0.3);
            --primary-light: rgba(var(--primary-rgb), 0.2);
            --channel-name-color: #e2e2ff;
            --player-bg: #1e1e1e;
            --channel-number-color: #b0b0b0
        }        body {
            background: #151515 !important;
            color: #e0e0e0 !important;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            transition: all .3s;
            overflow-x: hidden;
        }

        .channel-card {
            min-width: 140px;
            max-width: 140px;
            flex: 0 0 auto;
            scroll-snap-align: start;
            background: var(--card-bg);
            border: 0.5px solid var(--border-color);
            border-radius: var(--radius-md);
            padding: 0.25rem 0.5rem 0.5rem 0.5rem;
            cursor: pointer;
            box-shadow: var(--shadow-sm);
            transition: all .2s;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center
        }

        .status-message {
            text-align: center;
            padding: 0.25rem;
            font-size: .425rem;
            background-color: rgba(76, 201, 240, .1);
            border-radius: var(--radius-sm);
            margin-bottom: 0.25rem;
            opacity: 1;
            transition: all .5s ease-in-out, margin .5s ease-in-out;
            margin-left: auto;
            margin-right: auto;
            max-width: 400px;
            width: 90%;
            box-shadow: var(--shadow-sm);
            z-index: 50
        }

        .status-message.hide {
            opacity: 0;
            transform: translateY(-10px);
            pointer-events: none;
            margin-bottom: 0
        }

        .status-message.success {
            color: var(--primary);
            background-color: var(--primary-light)
        }

        .status-message.info {
            color: var(--primary);
            background-color: var(--primary-light)
        }

        .status-message.error {
            color: var(--text);
            background-color: rgba(247, 37, 133, .2)
        }

        .status-message.warning {
            color: var(--warning);
            background-color: rgba(248, 150, 30, .1)
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, .8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10001;
            backdrop-filter: blur(4px);
        }

        .modal--active {
            display: flex;
            overscroll-behavior: contain;
        }

        body:has(.modal--active) {
            overflow: hidden !important;
            height: 100vh;
        }        .modal__content {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 1rem;
            width: 90%;
            max-width: 280px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            border: 1px solid var(--border-color);
        }

        .modal__title {
            margin-bottom: 0.4rem;
            color: var(--text);
            font-size: 0.55rem;
            display: flex;
            align-items: center;
            gap: 4px
        }

        .modal__actions {
            display: flex;
            justify-content: flex-end;
            gap: 0.3rem;
            margin-top: 0.5rem
        }

        .modal__btn {
            padding: 0.25rem 0.4rem;
            border: none;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-weight: 500;
            font-size: 0.45rem;
            transition: all .2s
        }

        .modal__btn--primary {
            background: var(--primary);
            color: #fff
        }

        .modal__btn--primary:hover {
            background: var(--primary-dark)
        }

        .settings-section {
            margin-bottom: 0.6rem;
            padding-bottom: 0.5rem;
            border-bottom: 0.5px solid var(--border-color)
        }

        .settings-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0
        }

        .settings-section__title {
            font-size: 0.45rem;
            color: var(--primary);
            margin-bottom: 0.4rem;
            display: flex;
            align-items: center;
            gap: 4px
        }

        .settings-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.4rem;
            padding: 0.25rem;
            border-radius: var(--radius-sm);
            transition: background .2s
        }

        .settings-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .settings-item__info {
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 1
        }

        .settings-icon {
            font-size: 0.6rem
        }

        .settings-label {
            font-size: 0.45rem;
            color: var(--text);
            font-weight: 500;
            display: block
        }

        .settings-description {
            font-size: 0.375rem;
            color: var(--text);
            opacity: .7;
            display: block;
            margin-top: 1px
        }

        .settings-switch {
            position: relative;
            display: inline-block;
            width: 25px;
            height: 12px
        }

        .settings-switch input {
            opacity: 0;
            width: 0;
            height: 0
        }

        .settings-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 12px
        }

        body.dark-mode .settings-slider {
            background-color: #555555
        }

        .settings-slider:before {
            position: absolute;
            content: "";
            height: 8px;
            width: 8px;
            left: 2px;
            bottom: 2px;
            background-color: #fff;
            transition: .4s;
            border-radius: 50%
        }

        input:checked+.settings-slider {
            background-color: var(--primary)
        }

        input:checked+.settings-slider:before {
            transform: translateX(13px)
        }

        .color-picker {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 2px;
        }

        .color-option {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #555;
            cursor: pointer;
            transition: all 0.2s ease;
            flex-shrink: 0;
            display: inline-block;
        }

        .color-option:hover {
            transform: scale(1.1)
        }

        .color-option.active {
            border-color: var(--text);
            transform: scale(1.1)
        }

        .modal__title,
        .channel-option-name,
        .settings-label {
            color: var(--text) !important
        }

        .settings-description {
            color: var(--text) !important;
            opacity: .7 !important
        }

        .settings-section__title {
            color: var(--primary) !important
        }

        .degradado-comedia {
            background-image: linear-gradient(to right, #ff3c3c, orange);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight
        }

        .copy-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--card-bg);
            border: 0.5px solid var(--border-color);
            border-radius: var(--radius-md);
            padding: 0.75rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            z-index: 20000; /* Incrementado para estar por encima de todos los modales */
            width: 90%;
            max-width: 160px;
            display: none;
            flex-direction: column;
            align-items: center;
            text-align: center;
            animation: fadeIn .3s ease-out
        }

        .copy-modal.active {
            display: flex
        }

        .copy-modal-icon {
            font-size: 1.25rem;
            margin-bottom: 0.4rem
        }

        .copy-modal-text {
            font-size: 0.475rem;
            color: var(--text);
            margin-bottom: 0.5rem
        }

        .copy-modal-button {
            padding: 0.3rem 0.6rem;
            background: var(--primary);
            color: #fff;
            border: none;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: 0.45rem;
            font-weight: 600;
            transition: background .2s;
            margin-bottom: 0.25rem
        }

        .copy-modal-button:hover {
            background: var(--primary-dark)
        }

        .copy-modal-url {
            background-color: var(--bg-light);
            color: var(--text);
            padding: 0.25rem;
            margin-bottom: 0.5rem;
            border-radius: var(--radius-sm);
            font-family: monospace;
            word-break: break-all;
            font-size: 0.425rem;
            display: block
        }

        body.dark-mode .copy-modal-url {
            background-color: var(--border-color)
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translate(-50%, -60%)
            }

            to {
                opacity: 1;
                transform: translate(-50%, -50%)
            }
        }

        .copy-message {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--primary);
            color: #fff;
            padding: 0.3rem 0.6rem;
            border-radius: var(--radius-sm);
            font-size: 0.45rem;
            z-index: 20001; /* Ajustado para estar sobre el modal de copia */
            opacity: 0;
            transition: opacity .4s ease-in-out
        }

        .copy-message.show {
            opacity: 1
        }

        

        .live-time-blink {
            color: var(--primary) !important;
            animation: soft-blink 1.5s infinite ease-in-out;
            font-weight: 700
        }

        @keyframes soft-blink {

            0%,
            100% {
                opacity: 1
            }

            50% {
                opacity: .5
            }
        } 

        .tv-mode-active {
            background: #151515 !important;
            color: #e0e0e0 !important
        }        #tvSidebar {
            background: #111111;
            color: #e0e0e0;
            padding: 0.75rem 0.25rem;
            position: fixed;
            left: 0;
            top: 0;
            width: 50px;
            height: 100vh;
            overflow-y: auto;
            border-right: 0.5px solid #383838;
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            transition: all 0.3s ease-in-out;
        }

        

        #tvSidebar .tv-nav-link {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 4px 0;
            border-radius: 3px;
            color: #e0e0e0;
            text-decoration: none;
            font-weight: 600;
            transition: background-color 0.2s;
            text-align: center;
            font-size: 0.375rem;
            line-height: 1.1
        }       

        

        #tvSidebar .tv-nav-link span {
            margin-right: 0 !important;
            margin-bottom: 1.5px;
            font-size: 0.55rem !important
        }

        #tvSidebar .tv-nav-link:hover {
            background-color: #2d2d2d
        }

        /* Estilo de c√°psula para el bot√≥n activo */
        .tv-sidebar-link-focused {
            background-color: var(--primary) !important;
            border-radius: 50px !important; /* Forma de c√°psula */
            color: white !important;
            padding: 8px 15px !important;
            transition: all 0.3s ease;
        }

        /* Eliminado borde y escala previa para favorecer est√©tica de c√°psula limpia */

        #tvMainContent {
            margin-left: 50px;
            padding: 0.75rem 1.25rem;
            min-height: 100vh;
            background: #151515;
            display: flex;
            flex-direction: column;
          
            transition: all 0.3s ease-in-out;
        }

               @media screen and (orientation: portrait) {
            #tvSidebar {
                width: 100%;
                box-sizing: border-box;
                height: 50px;
                left: 0;
                top: auto;
                bottom: 0;
                padding: 0 10px;
                border-right: none;
                border-top: 0.5px solid #383838;
                flex-direction: row;
                justify-content: center;
                align-items: center;
                overflow: hidden;
            }

            #tvSidebar nav {
                width: 100%;
                margin: 0;
                padding: 0;
            }            #tvSidebar ul {
                display: flex;
                flex-direction: row-reverse;
                justify-content: space-around;
                width: 100%;
                margin: 0 !important;
                padding: 0 !important;
                list-style: none;
            }

            #tvSidebar li {
                margin: 0 !important;
                flex: 1;
                display: flex;
                justify-content: center;
                align-items: stretch;
                height: 100%;
            }

            #tvSidebar .tv-nav-link {
            padding: 5px;
            font-size: 0.45rem;
            width: auto; /* Permitir que la c√°psula no ocupe todo el ancho */
            min-width: 60px;
            height: 80%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            gap: 2px;
            transition: all 0.3s ease;
        }

            #tvSidebar .tv-nav-link span {
                font-size: 0.7rem !important;
                margin-bottom: 0 !important;
                pointer-events: none;
            }

            #tvMainContent {
                margin-left: 0;
                margin-bottom: 50px;
                min-height: calc(100vh - 50px);
                padding: 0.75rem;
                width: 100%;
                box-sizing: border-box;
            }

            #searchContainer {
                padding: 0.5rem;
                flex-direction: row;
                align-items: center;
            }
        }




        .tv-card {
            min-width: 150px;
            max-width: 150px;
            height: 84.5px;
            border-radius: 6px;
            background: #2d2d2d;
            border: 1px solid transparent;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: flex-start;
            padding: 8px; 
            cursor: pointer;
            transition: transform 0.3s ease-in-out, border-color 0.3s ease-in-out;
            background-size: contain;
            background-position: center center;
            background-repeat: no-repeat;
            background-origin: content-box;
            box-shadow: 0 2px 7.5px rgba(0, 0, 0, 0.4);
            box-sizing: border-box;
        }

        .tv-card-focused {
            transform: scale(1.05);
            border-color: var(--primary) !important;
            box-shadow: 0 4px 10px rgba(var(--primary-rgb), 0.5);
        }

        .tv-channels-grid {
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
            flex-grow: 1;
            min-height: 0;
            justify-content: flex-start;
        }

        .tv-group {
            padding: 0;
            margin-bottom: 0;
        }

        .tv-group-header {
            padding: 0 0 0.4rem 0;
            display: flex;
            align-items: center;
        }

        .tv-group-title {
            font-size: 0.75rem;
            font-weight: 700;
            color: #e0e0e0;
            padding-left: 0;
            width: 100%;
            margin-top: 0;
        }

        .tv-date-header {
            display: flex;
            align-items: center;
            text-align: center;
            font-size: 0.65rem;
            font-weight: 700;
            color: var(--gray-dark);
            margin: 2rem 0 1rem 0;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .tv-date-header::before, .tv-date-header::after {
            content: '';
            flex: 1;
            border-bottom: 1px solid var(--border-color);
        }

        .tv-date-header:not(:empty)::before {
            margin-right: 1.5rem;
        }

        .tv-date-header:not(:empty)::after {
            margin-left: 1.5rem;
        }

        .tv-date-header:first-of-type {
            margin-top: 0;
        }


        .tv-subgroup-content {
            display: flex;
            gap: 0.75rem;
            padding: 0.25rem 0;
            overflow-x: auto;
            overflow-y: hidden;
            white-space: nowrap;
            scroll-snap-type: x mandatory;
        }

        .tv-subgroup-content::-webkit-scrollbar {
            height: 0;
            display: none;
        }

        .modal__content {
            max-width: 225px;
        }

        .channel-option-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin-bottom: 6px;
            border-radius: 8px;
            background: #2a2a2a;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid #383838;
        }

        .channel-option-item:hover {
            background: #333333;
            border-color: var(--primary);
        }

        .channel-option-name {
            font-weight: 600;
            color: var(--text);
            flex-grow: 1;
            margin-left: 5px;
            font-size: 0.45rem;
        }

        .channel-option-name-container {
            display: flex;
            align-items: center;
            flex-grow: 1;
            font-weight: 600;
            color: var(--text);
        }

        .last-viewed-indicator {
            margin-left: 2.5px;
            margin-right: 5px;
            font-size: 0.55rem;
            color: var(--primary);
            font-weight: 700;
        }

        .channel-option-details {
            font-size: 0.4rem;
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .tv-link-button {
            position: absolute;
            bottom: 2.5px;
            right: 2.5px;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background-color: rgba(120, 120, 120, 0.15);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.45rem;
            box-shadow: 0 0.5px 2px rgba(0, 0, 0, 0.4);
            z-index: 50;
            transition: transform 0.2s, background-color 0.2s;
        }

        .tv-link-button:hover,
        .tv-link-button-focused {
            background-color: var(--primary);
            transform: scale(1.05);
        }

        .no-results-container {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-grow: 1;
            width: 100%;
            height: 100%
        }

        .no-results {
            text-align: center;
            padding: 1rem;
            background: var(--card-bg);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-sm);
            margin: auto;
            max-width: 400px;
            width: 90%
        }

        .no-results-icon {
            font-size: 1.5rem;
            margin-bottom: .5rem;
            opacity: .5;
            color: #666
        }

        .no-results-text {
            font-size: .55rem;
            color: var(--text);
            margin-bottom: .25rem;
            font-weight: 600
        }

        .no-results-hint {
            font-size: .45rem;
            color: var(--text);
            opacity: .7
        }

        body.dark-mode .no-results {
            background: #222;
            border: .5px solid #383838;
            box-shadow: none
        }

        body.dark-mode .no-results-icon {
            color: #666;
            opacity: 1
        }

        body.dark-mode .no-results-text {
            color: #e0e0e0
        }

        body.dark-mode .no-results-hint {
            color: #aaa
        }

        /* Estilos para la Loader Bar */
        #loader-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: transparent;
            z-index: 10001;
            transition: opacity 0.4s ease;
        }

        .loader-bar {
            height: 100%;
            width: 30%;
            background: var(--primary);
            box-shadow: 0 0 10px var(--primary);
            animation: loading-slide 2s infinite ease-in-out;
        }

        @keyframes loading-slide {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(400%); }
        }

        .loading-finished #loader-container {
            opacity: 0;
            pointer-events: none;
        }

        body.hide-options-button-active .tv-card .tv-link-button {
            visibility: hidden
        }

        #tvChannelsGrid.no-channels {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100%;
            min-height: 50vh;
            gap: 0
        }

        .tv-card h3 {
            display: none;
            font-size: 0.6rem;
            font-weight: 700;
            color: white;
            white-space: normal;
            margin: 0;
            text-align: center;
        
        }

    </style>
</head>

<body class="tv-mode-active dark-mode">
    <div id="loader-container">
        <div class="loader-bar"></div>
    </div>
    <aside id="tvSidebar">
        <nav>
                <ul style="list-style:none;padding:0;margin:0">
                    <li style="margin-bottom:.2rem"><a href="#" class="tv-nav-link" data-filter="search"> <span>üîç</span>Buscar</a></li>
                    <li style="margin-bottom:.25rem"><a href="#" class="tv-nav-link" data-filter="events_only"><span>üìÖ</span> Eventos </a></li>
                    <li style="margin-bottom:.25rem"><a href="#" id="settingsModeBtn" class="tv-nav-link"> <span>‚öôÔ∏è</span> Ajustes </a></li>
                    </ul>
            </nav>
        </div>
        
    </aside>
    <main id="tvMainContent">
        <div id="tvStatusMessageContainer" style="margin-bottom:.75rem"></div>
        <div id="searchContainer" style="display: none; margin-bottom: 0.75rem; padding: 0.5rem 0.75rem; background: #222222; border-radius: 6px; align-items: center; border: 1px solid #383838;">
            <span id="clearSearchLupa" style="font-size: 0.75rem; color: #e0e0e0; margin-right: 10px; cursor: pointer;">   üîç   </span>
            <input type="text" id="globalSearchInput" placeholder="Escribe para buscar"
                style="flex-grow: 1; padding: 8px 12px; border-radius: 4px; font-size: 0.75rem; box-sizing: border-box; background-color: #383838; color: #ffffff; border: 0.5px solid #555555; box-shadow: none;">
        </div>
        <h1 style="color:white;margin-top:0"></h1>
        <div class="tv-channels-grid" id="tvChannelsGrid"></div>
    </main>
    <div class="modal" id="settingsModal">
        <div class="modal__content">
            <h3 class="modal__title" id="devModeTrigger" style="cursor:pointer">‚öôÔ∏è Ajustes</h3>
            <div class="settings-section">
                <h4 class="settings-section__title">üì∫ Opciones de Interfaz</h4>
                <div class="settings-item dev-option" style="display:none">
                    <div class="settings-item__info"><span class="settings-icon">üñ•Ô∏è</span>
                        <div><span class="settings-label">Pantalla Completa al Clic</span><span
                                class="settings-description">Activa el modo de pantalla completa al hacer clic en
                                cualquier parte de la interfaz.</span></div>
                    </div><label class="settings-switch"><input type="checkbox" id="fullScreenOnClickCheckbox"><span
                            class="settings-slider"></span></label>
                </div>
                <div class="settings-item">
                    <div class="settings-item__info"><span class="settings-icon">‚ûï</span>
                        <div><span class="settings-label">Ocultar Bot√≥n de Opciones</span><span
                                class="settings-description">Mantiene la funcionalidad del bot√≥n '+' pero lo hace
                                invisible.</span></div>
                    </div><label class="settings-switch"><input type="checkbox" id="hideOptionsButtonCheckbox"><span
                            class="settings-slider"></span></label>
                </div>                <div class="settings-item dev-option" style="display:none">
                    <div class="settings-item__info"><span class="settings-icon">üìã</span>
                        <div><span class="settings-label">Copiar enlace en vez de abrir</span><span
                                class="settings-description">Al hacer clic en un canal, copia el ID de AceStream al portapapeles en lugar de intentar abrirlo.</span></div>
                    </div><label class="settings-switch"><input type="checkbox" id="copyLinkModeCheckbox"><span
                            class="settings-slider"></span></label>
                </div>
                <div class="settings-item dev-option" style="display:none">
                    <div class="settings-item__info"><span class="settings-icon">üö´</span>
                        <div><span class="settings-label">Ocultar Canales sin Link</span><span
                                class="settings-description">Hace invisibles las tarjetas que no tienen se√±al reproducible y oculta eventos vac√≠os.</span></div>
                    </div><label class="settings-switch"><input type="checkbox" id="hideNoLinksCheckbox"><span
                            class="settings-slider"></span></label>
                </div>
                <div class="settings-item">
                    <div class="settings-item__info"><span class="settings-icon">üì°</span>
                        <div><span class="settings-label">Motor de Eventos</span><span class="settings-description">Fuente de la agenda deportiva.</span></div>
                    </div>
                    <select id="eventSourceSelect" onchange="setEventSource(this.value)" style="background:#333; color:white; border:1px solid #555; font-size:0.45rem; border-radius:4px;">
                        <option value="ipfs">ERA</option>
                        
                        <option value="ciriaco">CRT</option>
                        <option value="ftv">FTV</option>
                    </select>
                </div>
            </div>
            <div class="settings-section">
                <h4 class="settings-section__title">üé® Apariencia</h4>
                <div class="settings-item">
                    <div class="settings-item__info"><span class="settings-icon">üé®</span>
                        <div><span class="settings-label">Color principal</span><span class="settings-description">Elige
                                un color para la interfaz</span></div>
                    </div>
                    <div class="color-picker"><button class="color-option" data-color="#2563eb"
                            style="background:#2563eb"></button><button class="color-option" data-color="#dc2626"
                            style="background:#dc2626"></button><button class="color-option" data-color="#16a34a"
                            style="background:#16a34a"></button><button class="color-option" data-color="#79006f"
                            style="background:#79006f"></button></div>
                </div>
            </div>
            <div class="settings-section">
                <h4 class="settings-section__title">üîß Datos</h4>
                <div class="settings-item dev-option" style="display:none">
                    <div class="settings-item__info"><span class="settings-icon">‚≠ê</span>
                        <div><span class="settings-label">Restablecer puntuaciones</span><span
                                class="settings-description">Borra la puntuaci√≥n de estabilidad de todos los
                                canales</span></div>
                    </div><button class="modal__btn" onclick="resetRatings()">Reiniciar</button>
                </div>                
                <div class="settings-item">
                    <div class="settings-item__info"><span class="settings-icon">‚ö°</span>
                        <div><span class="settings-label">Calibraci√≥n R√°pida</span><span
                                class="settings-description">Testea un enlace de cada canal r√°pidamente.</span></div>
                    </div><button class="modal__btn" onclick="startCalibration()" style="background-color: var(--primary); color: white;">Iniciar Test</button>
                </div>
                <div class="settings-item dev-option" style="display:none">
                    <div class="settings-item__info"><span class="settings-icon">üóëÔ∏è</span>
                        <div><span class="settings-label">Restablecer Web</span><span
                                class="settings-description">Borra absolutamente todos los datos (Favoritos, historial, ajustes).</span></div>
                    </div><button class="modal__btn btn-danger" onclick="factoryReset()" style="background-color: #dc2626; color: white;">Borrar Todo</button>
                </div>
            </div>
            <div class="modal__actions"><button class="modal__btn modal__btn--primary"
                    id="closeSettingsBtn">Cerrar</button></div>
        </div>
    </div>    <div class="copy-modal" id="copyModal">
        <div class="copy-modal-icon">üîó</div>
        <div class="copy-modal-text">Selecciona el formato de copia:</div>
        <p id="copyUrlDisplayAceStream" class="copy-modal-url" style="display:none"></p>
        <button class="copy-modal-button" id="copyAceStreamBtn" style="margin-bottom: 8px;">Copiar para AceStream</button>
        <button class="copy-modal-button" id="copyVlcBtn" style="background: #f8961e; margin-bottom: 12px;">Copiar para VLC</button>
        <button class="modal__btn modal__btn--cancel" id="cancelCopyBtn">Cancelar</button>
    </div>
    <div class="copy-message" id="copyMessage">URL copiada con √©xito!</div>
    <div class="modal" id="tvChannelOptionsModal">
        <div class="modal__content" style="max-width:225px">
            <h3 class="modal__title">üì∫ Opciones de Canal <span id="tvModalChannelName"></span></h3>
            <div id="tvModalChannelList" style="max-height:350px;overflow-y:auto"></div>
            <div class="modal__actions"><button class="modal__btn modal__btn--primary"
                    id="closeTvOptionsBtn">Cerrar</button></div>
        </div>
    </div>

    <div class="modal" id="calibrationModal">
        <div class="modal__content" style="max-width: 300px; text-align: center;">
            <h3 class="modal__title">‚ö° Calibrando: <span id="calibChannelName"></span></h3>
            <p style="font-size: 0.45rem; margin-bottom: 10px;">¬øFunciona la se√±al?</p>
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <button class="modal__btn" onclick="processCalibration(true)" style="background: var(--success); color: black; padding: 20px; font-size: 0.8rem; font-weight: bold;">‚úÖ S√ç FUNCIONA</button>
                <button class="modal__btn" onclick="processCalibration(false)" style="background: #dc2626; color: white; padding: 20px; font-size: 0.8rem; font-weight: bold;">‚ùå NO FUNCIONA</button>
            </div>
            <div class="modal__actions">
                <button class="modal__btn" onclick="stopCalibration()">Detener</button>
            </div>
        </div>
    </div>
    <script>
        let worker;
const state = {
            channelsData: [],
            channelHistory: JSON.parse(localStorage.getItem('channelHistory')) || {},
            currentChannel: null,
            primaryColor: localStorage.getItem('primaryColor') || '#2563eb',
            channelRatings: JSON.parse(localStorage.getItem('channelRatings')) || {},
            lastChannelPlay: JSON.parse(localStorage.getItem('lastChannelPlay')) || null,
            firstSeen: JSON.parse(localStorage.getItem('firstSeen')) || {},
            hideEventDetails: localStorage.getItem('hideEventDetails') === 'true',
            tvCurrentFilter: localStorage.getItem('tvCurrentFilter') || 'all',
            tvSportFilter: localStorage.getItem('tvSportFilter') || 'all',
            tvEventSource: localStorage.getItem('tvEventSource') || 'ipfs',
            eventsCache: { ipfs: [], ciriaco: [], ftv: [] },
            tvSearchTerm: '',
            tvFocusManager: null,
            playerActive: false,
            lastPlayedByChannel: JSON.parse(localStorage.getItem('lastPlayedByChannel')) || {},
            channelLogos: JSON.parse(localStorage.getItem('channelLogos')) || {},
            fullScreenOnClick: localStorage.getItem('fullScreenOnClick') === 'true',
            hideOptionsButton: localStorage.getItem('hideOptionsButton') === 'true',
            copyLinkMode: localStorage.getItem('copyLinkMode') === 'true', hideNoLinks: localStorage.getItem('hideNoLinks') !== 'false',
            calibrationQueue: [],
            isCalibrating: false,
            devClickCount: 0
        };
        const LOGOPEDIA_BASE_URL = "https://static.wikia.nocookie.net/logopedia/images/";
        const IMAGE_PROXY_URL = "https://images.weserv.nl/?url=";
        const ERA_URL = "https://ipfs.io/ipns/k2k4r8oqlcjxsritt5mczkcn4mmvcmymbqw7113fz2flkrerfwfps004/data/listas/listaplana.txt";

        // Se elimina el objeto championsLeagueImages

        function getPlaceholderInfo(channelName) {
            // MODIFICADO: Ahora busca en el nuevo estado de logos
            const logoUrl = state.channelLogos[channelName.trim()];
            if (logoUrl) {
                return {
                    logo: proxyImage(logoUrl),
                    color: null // Mantenerlo nulo para que use el color por marca o el predeterminado
                };
            }
            return null;
        }

        function proxyImage(url) {
            return IMAGE_PROXY_URL + encodeURIComponent(url);
        }
        const PROXIES = [
            'https://api.codetabs.com/v1/proxy/?quest=',
            'https://api.allorigins.win/raw?url=',
            'https://thingproxy.freeboard.io/fetch/',
            'https://corsproxy.io/?'
        ];
        const GIST_URL = "https://gist.githubusercontent.com/Ciento20/f7847e86d06e5011706fa76f2dab90be/raw";
        const ELCANO_URL = 'https://acestream-ids.vercel.app/';
        const EVENTS_SOURCES = {
            
            ciriaco: 'https://ciriaco.netlify.app/',
            ipfs: 'https://ipfs.io/ipns/k2k4r8oqlcjxsritt5mczkcn4mmvcmymbqw7113fz2flkrerfwfps004/',
            ftv: 'https://www.futbolenlatv.es/deporte'
        };
        const SHICKAT_URL = 'https://shickat.me/';
        const BACKUP_KEYS = {
            
            elcano: 'elcano_channels_backup',
            events: 'events_channels_backup',
            shickat: 'shickat_channels_backup',
            era: 'era_channels_backup',
            logos: 'logos_backup' // NUEVO: Clave para el backup de logos
        };
        const MAX_RETRIES = 3;
        const BACKUP_EXPIRY_HOURS = 480;
        const HISTORY_EXPIRY_HOURS = 168;
        // Limpieza: Se confirma la eliminaci√≥n de 'favorites' para optimizaci√≥n de interfaz TV
        const TV_BRAND_FILTER_KEYS = ['all', 'events_only', 'live', 'search', 'dazn', 'm+', 'eurosport'];
        const TV_SPORT_FILTER_KEYS = ['futbol', 'baloncesto', 'tenis', 'motor', 'f1', 'ciclismo'];
        const OTHER_SUBGROUPS = ['LIGA ENDESA', 'CANAL DE TENIS', 'SUPERTENNIS', 'BUNDESLIGA', 'PRIMERA FEDERACI√ìN', '1RFEF', 'ARAGON TV', 'BEIN', 'BT SPORT', 'CANAL+SPORT', 'ESPN', 'ESSPN', 'SKY', 'ESPORT 3', 'FOX', 'GOL PLAY', 'REAL MADRID TV', 'ORANGE TV', 'RALLY TV', 'MOTOR', 'NBA', 'NFL', 'PREMIER SPORTS', 'DISCOVERY CHANNEL', 'DARK', 'AMC', 'LA 1', 'LA 2', 'ANTENA 3', 'Cuatro', 'Telecinco', 'LA SEXTA', '24 HORAS', 'TELEDEPORTE', 'CAZA Y PESCA', 'CANAL COCINA', 'DECASA', 'ONETORO', 'ZIGGO', 'XTRM', 'MIXED TV', 'DAZN', 'DE', 'PL', 'RU'];

        function normalizeText(text) {
            if (!text) return '';
            return text.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
        }

        
        async function hashContent(text) {
            const encoder = new TextEncoder();
            const data = encoder.encode(text);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            return hashHex;
        }

        function trackFirstSeen(channelId) {
            if (!state.firstSeen[channelId]) {
                state.firstSeen[channelId] = new Date().getTime();
                localStorage.setItem('firstSeen', JSON.stringify(state.firstSeen));
            }
        }

        function isChannelNew(channelId) {
            const firstSeenTime = state.firstSeen[channelId];
            if (!firstSeenTime) {
                return false;
            }
            const tenMinutesInMs = 10 * 60 * 1000;
            return (new Date().getTime() - firstSeenTime) < tenMinutesInMs;
        }

        function cleanupOldFirstSeenRecords() {
            const oneWeekInMs = 7 * 24 * 60 * 60 * 1000;
            const now = new Date().getTime();
            for (const channelId in state.firstSeen) {
                if ((now - state.firstSeen[channelId]) > oneWeekInMs) {
                    delete state.firstSeen[channelId];
                }
            }
            localStorage.setItem('firstSeen', JSON.stringify(state.firstSeen));
        }

        

        function toggleFullScreenOnClick() {
            state.fullScreenOnClick = !state.fullScreenOnClick;
            localStorage.setItem('fullScreenOnClick', state.fullScreenOnClick);
            document.getElementById('fullScreenOnClickCheckbox').checked = state.fullScreenOnClick;
        }

        function toggleHideOptionsButton() {
            state.hideOptionsButton = !state.hideOptionsButton;
            localStorage.setItem('hideOptionsButton', state.hideOptionsButton);
            document.getElementById('hideOptionsButtonCheckbox').checked = state.hideOptionsButton;
            document.getElementById('copyLinkModeCheckbox').checked = state.copyLinkMode;
            document.body.classList.toggle('hide-options-button-active', state.hideOptionsButton);
            renderTVChannels();
        }        function toggleCopyLinkMode() {
            state.copyLinkMode = !state.copyLinkMode;
            localStorage.setItem('copyLinkMode', state.copyLinkMode);
            document.getElementById('copyLinkModeCheckbox').checked = state.copyLinkMode;
            showStatusMessage(state.copyLinkMode ? "Modo Copiar Enlace activado" : "Modo Reproducci√≥n directa activado", "info");
        }

        function toggleHideNoLinks() {
            state.hideNoLinks = !state.hideNoLinks;
            localStorage.setItem('hideNoLinks', state.hideNoLinks);
            document.getElementById('hideNoLinksCheckbox').checked = state.hideNoLinks;
            renderTVChannels();
        }

        function setEventSource(source) {
            state.tvEventSource = source;
            localStorage.setItem('tvEventSource', source);
            
            // Recargar datos desde el cach√© local sin fetch
            const baseChannels = state.channelsData.filter(c => c.source !== 'events');
            state.channelsData = baseChannels.concat(state.eventsCache[source] || []);
            
            processChannelNames();
            renderTVChannels();
            showStatusMessage(`Motor de eventos cambiado a: ${source.toUpperCase()}`, "success");
        }

        function requestFullScreen() {
            if (document.fullscreenElement) {
                return;
            }
            const element = document.documentElement;
            if (element.requestFullscreen) {
                element.requestFullscreen();
            } else if (element.mozRequestFullScreen) {
                element.mozRequestFullScreen();
            } else if (element.webkitRequestFullscreen) {
                element.webkitRequestFullscreen();
            } else if (element.msRequestFullscreen) {
                element.msRequestFullscreen();
            }
        }

        function clearAllTVFilterVisuals() {
            document.querySelectorAll('#tvSidebar .tv-nav-link').forEach(link => {
                link.classList.remove('tv-sidebar-link-focused');
            });
            
        }

        function applyTVFilter(filter, type) {
            let updateNeeded = false;
            if (type === 'brand') {
                if (filter === 'search') {
                    // Siempre activa el modo b√∫squeda al pulsar el bot√≥n, sin alternar el cierre
                    state.tvCurrentFilter = 'search';
                    localStorage.setItem('tvCurrentFilter', 'search');
                    // Si ya hab√≠a un t√©rmino, lo mantenemos; si no, aseguramos que est√© listo
                    updateNeeded = true;
                } else if (state.tvCurrentFilter !== filter) {
                    state.tvCurrentFilter = filter;
                    localStorage.setItem('tvCurrentFilter', filter);
                    // Si se cambia a otro filtro, limpiar el t√©rmino de b√∫squeda y desactivar modo b√∫squeda
                    if (filter !== 'search') {
                        state.tvSearchTerm = '';
                    }
                    updateNeeded = true;
                } else if (filter === 'all' || filter === 'live' || filter === 'events_only') {
                    updateNeeded = false; // No hacer nada si se vuelve a pulsar
                } else {
                    // Desactivar filtro de marca si se pulsa de nuevo
                    state.tvCurrentFilter = 'all';
                    localStorage.setItem('tvCurrentFilter', 'all');
                    updateNeeded = true;
                }

                if (state.tvSportFilter !== 'all') {
                    state.tvSportFilter = 'all';
                    localStorage.setItem('tvSportFilter', 'all');
                    updateNeeded = true;
                }
            }
            if (type === 'sport') {
                state.tvSportFilter = state.tvSportFilter === filter ? 'all' : filter;
                localStorage.setItem('tvSportFilter', state.tvSportFilter);
                updateNeeded = true;
                if (state.tvSportFilter !== 'all' && state.tvCurrentFilter !== 'all') {
                    state.tvCurrentFilter = 'all';
                    localStorage.setItem('tvCurrentFilter', 'all');
                }
            }
            if (updateNeeded) {
                renderTVChannels();
                // NUEVA L√ìGICA: Enfocar el cuadro de b√∫squeda si el filtro 'search' est√° activo
                if (state.tvCurrentFilter === 'search') {
                    document.getElementById('globalSearchInput')?.focus();
                }
            }
        }

        function showStatusMessage(message, type = "info") {
            let statusElement;
            let container;
            container = document.getElementById('tvStatusMessageContainer');
            statusElement = container.querySelector(".status-message");
            if (!statusElement) {
                statusElement = document.createElement("div");
                statusElement.className = "status-message";
                container.prepend(statusElement);
            }
            statusElement.textContent = message;
            statusElement.className = `status-message ${type}`;
            statusElement.classList.remove('hide');
            if (type === 'error') {
                statusElement.style.color = 'var(--text)';
            } else if (type === 'warning') {
                statusElement.style.color = 'var(--warning)';
            } else if (type === 'success' || type === 'info') {
                statusElement.style.color = 'var(--primary)';
            } else {
                statusElement.style.color = '';
            }
            if (type === "success" || type === "info") {
                setTimeout(() => {
                    statusElement.classList.add('hide');
                    statusElement.addEventListener('transitionend', () => {
                        if (statusElement.classList.contains('hide')) {
                            statusElement.remove();
                        }
                    }, {
                        once: true
                    });
                }, 3000);
            }
        }

        function saveBackup(data, key, contentHash = null) {
            try {
                localStorage.setItem(key, JSON.stringify({
                    timestamp: new Date().getTime(),
                    data,
                    contentHash
                }));
            } catch (e) {
                console.error(`Error al guardar la copia de seguridad para ${key}:`, e);
            }
        }

        function loadBackup(key) {
            try {
                const backupData = localStorage.getItem(key);
                if (backupData) {
                    const {
                        timestamp,
                        data,
                        contentHash
                    } = JSON.parse(backupData);
                    const backupAgeHours = (new Date().getTime() - timestamp) / (1000 * 60 * 60);
                    if (backupAgeHours > BACKUP_EXPIRY_HOURS) {
                        localStorage.removeItem(key);
                        return null;
                    }
                    return {
                        timestamp,
                        data,
                        contentHash
                    };
                }
            } catch (e) {
                console.error(`Error al cargar la copia de seguridad para ${key}:`, e);
            }
            return null;
        }

        function mergeChannels(channelsArray) {
            const allChannels = channelsArray;
            const eventChannels = allChannels.filter(channel => channel.source === 'events');
            const otherChannels = allChannels.filter(channel => channel.source !== 'events');
            
            // Unificamos las bibliotecas de enlaces manteniendo su prioridad
            // Eliminamos el filtro de 'eventIds' para que las fuentes no desaparezcan al haber eventos activos
            const uniqueOtherChannelsMap = new Map();
            const orderedOtherSources = ['elcano', 'shickat', 'era', 'gist'];
            
            orderedOtherSources.forEach(source => {
                otherChannels.forEach(channel => {
                    if (channel.source === source) {
                        if (!uniqueOtherChannelsMap.has(channel.id)) {
                            uniqueOtherChannelsMap.set(channel.id, channel);
                        }
                    }
                });
            });
            
            const mergedOtherChannels = Array.from(uniqueOtherChannelsMap.values());
            return eventChannels.concat(mergedOtherChannels);
        }

        function loadAndRenderBackupChannels() {
            let allBackupChannels = [];
            let hasBackup = false;
            for (const key in BACKUP_KEYS) {
                // Excluimos la clave 'logos' ya que es un mapa de URLs y no una lista de canales para renderizar.
                if (key === 'logos') continue;
                const backup = loadBackup(BACKUP_KEYS[key]);
                if (backup && backup.data) {
                    allBackupChannels = allBackupChannels.concat(backup.data.map(c => ({
                        ...c,
                        source: key,
                        name: c.name || `Canal de ${key.toUpperCase()}`,
                        id: c.id || `${key}_${Math.random()}`,
                        number: (c.id || `${key}_${Math.random()}`).substring(0, 3),
                        displayableName: c.displayableName || c.name
                    })));
                    hasBackup = true;
                }
            }
            if (allBackupChannels.length > 0) {
                const newChannels = mergeChannels(allBackupChannels);
                state.channelsData = newChannels;
                processChannelNames();
                renderTVChannels();
                return true;
            }
            return false;
        }
        // NUEVA FUNCI√ìN: Carga y procesa el Gist como fuente de Logos
        async function loadChannelLogos() {
            let logos = {};
            const backupKey = BACKUP_KEYS.logos;

            try {
                const response = await fetch(GIST_URL);
                if (!response.ok) throw new Error("Error al obtener el contenido del Gist (Logos)");
                const infoContent = await response.text();

                const contentHash = await hashContent(infoContent);
                const backup = loadBackup(backupKey);

                if (backup && backup.contentHash === contentHash) {
                    logos = backup.data;
                    console.log("[Logos] Contenido sin cambios. Usando backup local.");
                } else {
                    logos = processGistLogos(infoContent);
                    saveBackup(logos, backupKey, contentHash);
                    console.log("[Logos] Contenido actualizado o nuevo. Procesado y guardado.");
                }

            } catch (error) {
                console.error(`Fallo al cargar de Gist (Logos):`, error);

                const backup = loadBackup(backupKey);
                if (backup && backup.data) {
                    logos = backup.data;
                    console.log(`Fallo de Gist (Logos). Mostrando logos del historial.`);
                } else {
                    console.log(`Fallo de Gist (Logos). Sin historial disponible.`);
                }
            }

            state.channelLogos = logos;
            localStorage.setItem('channelLogos', JSON.stringify(logos));
        }

        // NUEVA FUNCI√ìN: Procesar el contenido del Gist para obtener Logos
        function processGistLogos(infoContent) {
            const logosMap = {};
            const lines = infoContent.split('\n').filter(line => line.trim() !== '');

            for (const line of lines) {
                const parts = line.split(': ');
                if (parts.length >= 2) {
                    const name = parts[0].trim();
                    // La URL puede contener ": " si es un proxy o un protocolo (ej: https://)
                    const url = parts.slice(1).join(': ').trim();
                    if (name && url.startsWith('http')) {
                        logosMap[name.toUpperCase().trim()] = url;
                    }
                }
            }

            // Mapeamos a las versiones simplificadas de los nombres
            const simplifiedLogosMap = {};
            for (const rawName in logosMap) {
                let simplifiedName = rawName;

                // Aplicar la normalizaci√≥n que se hace en cleanNameAndExtractQuality (solo para Eurosport/Teledeporte)
                const {
                    name: cleanedName
                } = cleanNameAndExtractQuality(rawName);
                simplifiedLogosMap[cleanedName.toUpperCase().trim()] = logosMap[rawName];

                // Si el nombre crudo ya era la versi√≥n simplificada, simplemente lo a√±adimos tambi√©n
                simplifiedLogosMap[rawName.toUpperCase().trim()] = logosMap[rawName];
            }

            return simplifiedLogosMap;
        }

        async function fetchAndProcessSource(sourceName, url, processor, backupKey) {
            let channels = null;
            let message = '';
            let contentHash = null;
            const retryKey = `${sourceName}Retries`;
            const currentRetries = state[retryKey] !== undefined ? state[retryKey] : 0;

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error("Error al obtener el contenido de la fuente");
                const infoContent = await response.text();

                if (state[retryKey] !== undefined) state[retryKey] = 0;
                contentHash = await hashContent(infoContent);
                const backup = loadBackup(backupKey);

                if (backup && backup.contentHash === contentHash) {
                    channels = backup.data;
                    message = `Canales de ${sourceName} cargados (Sin cambios).`;
                    console.log(`[${sourceName}] Contenido sin cambios. Usando backup local.`);
                } else {
                    channels = await processor(infoContent);
                    saveBackup(channels, backupKey, contentHash);
                    message = `Canales de ${sourceName} cargados y actualizados.`;
                    console.log(`[${sourceName}] Contenido actualizado o nuevo. Procesado y guardado.`);
                }

            } catch (error) {
                console.error(`Fallo al cargar de ${sourceName} (Intento ${currentRetries + 1}):`, error);
                
                if (state[retryKey] !== undefined && state[retryKey] < MAX_RETRIES) {
                    state[retryKey]++;
                    const delay = Math.pow(2, state[retryKey]) * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return fetchAndProcessSource(sourceName, url, processor, backupKey);
                }

                const backup = loadBackup(backupKey);
                if (backup && backup.data) {
                    channels = backup.data;
                    message = `Fallo de ${sourceName} tras ${state[retryKey] || 0} reintentos. Mostrando historial.`;
                } else {
                    message = `Fallo de ${sourceName} tras ${state[retryKey] || 0} reintentos. Sin historial disponible.`;
                }
            }

            return {
                name: sourceName,
                channels,
                message
            };
        }
        async function loadInitialChannels() {
            document.body.classList.remove('loading-finished');
            document.getElementById('tvStatusMessageContainer').innerHTML = '';
            
            await loadChannelLogos();
            
            // Carga inicial de backups para mostrar algo de inmediato
            loadAndRenderBackupChannels();

            const updateStateAndRender = (newChannels) => {
                if (!newChannels || newChannels.length === 0) return;
                const combined = state.channelsData.concat(newChannels);
                const merged = mergeChannels(combined);
                worker.postMessage({ task: 'processChannels', data: merged });
            };

            // Lanzamos todas las peticiones en paralelo y cada una actualiza seg√∫n llega
            const sources = [
                { name: 'era', url: ERA_URL, proc: processEraData, key: BACKUP_KEYS.era, type: 'direct' },
                { name: 'shickat', url: SHICKAT_URL, proc: processShickatData, key: BACKUP_KEYS.shickat, type: 'proxy' },
                { name: 'elcano', url: ELCANO_URL, proc: processElcanoDataFromHtml, key: BACKUP_KEYS.elcano, type: 'proxy' },
                { name: 'events_ipfs', url: EVENTS_SOURCES.ipfs, proc: processEventsData, key: BACKUP_KEYS.events, type: 'direct', isEvent: true },
                { name: 'events_ciriaco', url: EVENTS_SOURCES.ciriaco, proc: processCiriacoData, key: BACKUP_KEYS.events, type: 'proxy', isEvent: true },
                { name: 'events_ftv', url: EVENTS_SOURCES.ftv, proc: processFutbolEnLaTvData, key: BACKUP_KEYS.events, type: 'proxy', isEvent: true }
            ];

            let finishedCount = 0;
            sources.forEach(source => {
                const fetchMethod = source.type === 'direct' ? fetchAndProcessSource : fetchProxyContentAndProcess;
                
                fetchMethod(source.name, source.url, source.proc, source.key)
                    .then(result => {
                        if (result && result.channels) {
                            // Si es fuente de eventos, guardamos en cache
                            if (source.isEvent) {
                                const cleanName = source.name.replace('events_', '');
                                state.eventsCache[cleanName] = result.channels;
                                // Solo renderizamos si es la fuente activa de eventos
                                if (cleanName === state.tvEventSource) updateStateAndRender(result.channels);
                            } else {
                                updateStateAndRender(result.channels);
                            }
                        }
                    })
                    .finally(() => {
                        finishedCount++;
                        if (finishedCount === sources.length) {
                            document.body.classList.add('loading-finished');
                            cleanObsoleteRatings();
                        }
                    });
            });
        }

        // NUEVA FUNCI√ìN CENTRAL DE LIMPIEZA
        function cleanNameAndExtractQuality(rawName) {
            let name = rawName.replace(/(\(|\)|-->.*$)/g, '').trim();
            const quality = standardizeQuality(name);
            const multiAudio = name.toUpperCase().includes('MULTI');

            name = name
                .replace(/1080P|1080|720P|720|UHD|FHD|HD|SD|MultiAudio|Multi Audio|Multi|multi|4K/gi, '')
                .replace(/\(ES\)|\(Es\)|(Estable|New Era I|New Era II|New Loop|New Era VI|F√≥rmula 1|BAR|eleven|eventos)/gi, '')
                .replace(/\s+/g, ' ')
                .trim();            if (name.includes('Eurosport 1')) {
                name = '‚òÖEUROSPORT 1';
            } else if (name.includes('Eurosport 2')) {
                name = '‚òÖEUROSPORT 2';
            } else if (name.includes('Eurosport')) {
                name = '‚òÖEUROSPORT 1';
            } else if (name.includes('Teledeporte')) {
                name = 'Teledeporte';
            } else if (/dazn/gi.test(name)) {
                name = name.replace(/dazn/gi, 'DAZN');
            }

            return { name, quality, multiAudio };
        }

        

        async function processEraData(infoContent) {
            const numberedChannels = [];
            const lines = infoContent.split('\n').filter(line => line.trim() !== '');

            // --- Mapeos espec√≠ficos de ERA (anteriormente Gist) ---
            const channelMappings = {
          'MOVISTAR': 'M+',
          'LA LIGA': 'La Liga',
          'LALIGA': 'La Liga',
          'Premier': 'Premier League',
          'EUROSPORT': '‚òÖEUROSPORT',
          'HYPERMOTION': 'La Liga Hypermotion',
          'LIGA DE CAMPEONES': 'M+ Liga de Campeones',
          'ACCION': 'Acci√≥n',
          'CLASICOS': 'Cl√°sicos',
          'PLUS': 'Plus',
          'GOLF': 'Golf',
          'VAMOS': 'Vamos',
          'BALONCESTO 1': 'Baloncesto',
          'M. DEPORTES ES': 'M+ Deportes',
          'DEPORTES': 'Deportes ',
          'TELEDEPORTE': 'Teledeporte',
          'ELLAS': 'Ellas Vamos',
          'BALONCESTO': 'Baloncesto',
          'LA LIGA 1': 'La Liga',
          'CANAL 1 1RFEF SOLO': 'PRIMERA FEDERACI√ìN'
};
            // ----------------------------------------------------

            for (let i = 0; i < lines.length; i += 2) {
                const nameLine = lines[i].trim();
                const idLine = lines[i + 1] ? lines[i + 1].trim() : '';
                if (nameLine.includes('-->') && idLine.length > 0) {
                    let namePart = nameLine.split('-->')[0].trim().toUpperCase();
                    const acestreamId = idLine.replace(/p$/, '');
                    if (acestreamId.length === 40) {

                        // 1. Aplicar mapeo de nombre espec√≠fico de ERA
                        let simplifiedName = namePart;
                        for (const key in channelMappings) {
                            const regex = new RegExp(key, 'gi');
                            if (regex.test(simplifiedName)) {
                                simplifiedName = simplifiedName.replace(regex, channelMappings[key]);
                            }
                        }

                        // 2. Limpiar calidad/multi-audio y normalizar
                        const {
                            name,
                            quality,
                            multiAudio
                        } = cleanNameAndExtractQuality(simplifiedName);

                        numberedChannels.push({
                            id: acestreamId,
                            number: acestreamId.substring(0, 3),
                            name: name,
                            quality: quality,
                            multiAudio: multiAudio,
                            isKnown: true,
                            source: 'era'
                        });
                        trackFirstSeen(acestreamId);
                    }
                }
            }
            return numberedChannels;
        }

        async function fetchProxyContentAndProcess(sourceName, url, processor, backupKey) {
            let content = null;
            let finalMessage = '';
            const retryKey = `${sourceName}Retries`;
            const currentRetries = state[retryKey] !== undefined ? state[retryKey] : 0;

            // Intentamos con los primeros 3 proxies en paralelo para ganar velocidad
            const rapidProxies = PROXIES.slice(0, 3);
            
            try {
                content = await Promise.any(rapidProxies.map(proxy => 
                    fetch(proxy + encodeURIComponent(url)).then(res => {
                        if (!res.ok) throw new Error('Fail');
                        return res.text();
                    })
                ));
            } catch (e) {
                // Si los r√°pidos fallan, probamos el resto secuencialmente como fallback
                for (const proxy of PROXIES.slice(3)) {
                    try {
                        const res = await fetch(proxy + encodeURIComponent(url));
                        if (res.ok) {
                            content = await res.text();
                            break;
                        }
                    } catch (err) { continue; }
                }
            }

            if (content) {
                if (state[retryKey] !== undefined) state[retryKey] = 0;
                const contentHash = await hashContent(content);
                const backup = loadBackup(backupKey);

                if (backup && backup.contentHash === contentHash) {
                    return { name: sourceName, channels: backup.data, message: `Canales de ${sourceName} cargados (Sin cambios).` };
                } else {
                    const channels = await processor(content);
                    saveBackup(channels, backupKey, contentHash);
                    return { name: sourceName, channels, message: `Canales de ${sourceName} cargados y actualizados.` };
                }
            }

            if (state[retryKey] !== undefined && state[retryKey] < MAX_RETRIES) {
                state[retryKey]++;
                console.log(`Reintentando lista de proxies para ${sourceName} (Intento ${state[retryKey]})`);
                await new Promise(resolve => setTimeout(resolve, 2000));
                return fetchProxyContentAndProcess(sourceName, url, processor, backupKey);
            }

            const backup = loadBackup(backupKey);
            if (backup && backup.data) {
                finalMessage = `Fallo de ${sourceName} tras ${state[retryKey] || 0} ciclos de proxies. Mostrando historial.`;
                return {
                    name: sourceName,
                    channels: backup.data,
                    message: finalMessage
                };
            } else {
                finalMessage = `Fallo de ${sourceName} tras ${state[retryKey] || 0} ciclos de proxies. Sin historial disponible.`;
                throw lastError || new Error(`Todos los proxies fallaron para la fuente ${sourceName}.`);
            }
        }

        

        function processElcanoDataFromHtml(htmlContent) {
            const jsonMatch = htmlContent.match(/const links\s*=\s*(\[[\s\S]*?\]);/);
            if (!jsonMatch) throw new Error("No se encontr√≥ el array 'links' en el nuevo formato de Elcano.");
            try {
                const links = JSON.parse(jsonMatch[1]);
                return processElcanoData(links);
            } catch (e) {
                console.error("Error al parsear links de Elcano:", e);
                throw e;
            }
        }

        

        

        function processShickatData(htmlContent) {
            const numberedChannels = [];
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlContent, 'text/html');
            const cards = doc.querySelectorAll('article.canal-card');

            // --- Mapeos espec√≠ficos de Shickat ---
            const nameMappings = {
          'Ellas Vamos': 'Ellas',
          'Movistar': 'M+',
          'Clasicos': 'Cl√°sicos',
          'Accion': 'Acci√≥n',
          'Deportes': 'Deportes',
          'Plus': 'Plus',
          'M+ Liga de Campeones': 'M+ Liga de Campeones',
          'Golf': 'Golf'
};
            // ------------------------------------

            cards.forEach(card => {
                const nameElement = card.querySelector('.canal-nombre');
                const acestreamLinkElement = card.querySelector('.acestream-link');
                if (nameElement && acestreamLinkElement) {
                    const rawName = nameElement.textContent.trim();
                    const acestreamId = acestreamLinkElement.textContent.trim();
                    if (acestreamId.length === 40) {

                        // 1. Aplicar mapeo de nombre espec√≠fico de Shickat
                        let simplifiedName = rawName;
                        for (const key in nameMappings) {
                            if (simplifiedName.includes(key)) {
                                simplifiedName = simplifiedName.replace(key, nameMappings[key]);
                                break;
                            }
                        }
                        const normalizedSimplified = simplifiedName.toUpperCase();
                        if (normalizedSimplified.includes('M. LALIGA') || normalizedSimplified.includes('MOVISTAR LALIGA')) {
                            simplifiedName = 'M+ La Liga';
                        } else if (normalizedSimplified.includes('MOVISTAR')) {
                            simplifiedName = simplifiedName.replace(/Movistar/gi, 'M+');
                        }
                        if (normalizedSimplified.includes('LALIGA')) {
                            simplifiedName = simplifiedName.replace(/LaLiga/gi, 'La Liga');
                        }
                        if (normalizedSimplified.includes('DAZN')) {
                            simplifiedName = simplifiedName.replace(/Dazn/gi, 'DAZN');
                        }

                        // 2. Limpiar calidad/multi-audio y normalizar
                        const {
                            name,
                            quality,
                            multiAudio
                        } = cleanNameAndExtractQuality(simplifiedName);

                        numberedChannels.push({
                            id: acestreamId,
                            number: acestreamId.substring(0, 3),
                            name: name,
                            quality: quality,
                            multiAudio: multiAudio,
                            isKnown: true,
                            source: 'shickat'
                        });
                        trackFirstSeen(acestreamId);
                    }
                }
            });
            return numberedChannels;
        }

        function processElcanoData(links) {
            const numberedChannels = [];

            // --- Mapeos espec√≠ficos de Elcano ---
            const nameMap = {
          'LALIGA TV HYPERMOTION': 'La Liga Hypermotion',
          'DAZN F1': 'DAZN F1',
          'EUROSPORT': '‚òÖEUROSPORT',
          'DAZN Laliga': 'DAZN La Liga',
          'LaLiga': 'La Liga',
          'ACB 1': 'ACB',
          'BUNDESLIGA 1': 'BUNDESLIGA',
          'LALIGA': 'La Liga'
};
            // ------------------------------------

            links.forEach(link => {
                if (link.url && link.url.startsWith('acestream://')) {
                    const acestreamId = link.url.split('://')[1];

                    // 1. Aplicar mapeo de nombre espec√≠fico de Elcano
                    let simplifiedName = link.name.replace(/\s+/g, ' ').replace(/\*/g, '').trim();
                    const normalizedForMap = simplifiedName.toUpperCase();
                    for (const key in nameMap) {
                        const upperKey = key.toUpperCase();
                        if (normalizedForMap.includes(upperKey)) {
                            const regex = new RegExp(key, 'gi');
                            simplifiedName = simplifiedName.replace(regex, nameMap[key]);
                            break;
                        }
                    }                    // 2. Limpiar calidad/multi-audio y normalizar
                    // Enviamos el nombre ya simplificado (con DAZN corregido) a la limpieza final
                    const {
                        name,
                        quality,
                        multiAudio
                    } = cleanNameAndExtractQuality(simplifiedName);

                    numberedChannels.push({
                        id: acestreamId,
                        number: acestreamId.substring(0, 3),
                        name: name,
                        quality: quality,
                        multiAudio: multiAudio,
                        isKnown: true,
                        source: 'elcano'
                    });
                    trackFirstSeen(acestreamId);
                }
            });
            return numberedChannels;
        }

        function calculateDuration(sportName) {
            const normalizedName = normalizeText(sportName);

            // --- L√≥gica Espec√≠fica para F1/Motorsport ---
            if (normalizedName.includes('formula 1') || normalizedName.includes('f1')) {
                if (normalizedName.includes('practice') || normalizedName.includes('entrenamiento')) {
                    // Ejemplo: Free Practice / Pr√°ctica Libre -> 1 hora y 5 minutos
                    return 65;
                } else if (normalizedName.includes('qualifying') || normalizedName.includes('clasificacion')) {
                    // Ejemplo: Qualifying / Clasificaci√≥n -> 1 hora y 30 minutos
                    return 90;
                } else if (normalizedName.includes('race') || normalizedName.includes('carrera') || normalizedName.includes('gp')) {
                    // Ejemplo: Race / Carrera (incluye el previo/post de 1 hora)
                    return 180;
                }
                return 180; // Default para F1 si no se especifica el tipo de evento
            }

            // --- L√≥gica General de Deportes ---
            if (normalizedName.includes('futbol')) return 120; // 90 min + 30 min (previo/descanso/post)
            if (normalizedName.includes('baloncesto') || normalizedName.includes('nba')) return 150; // 48 min de juego + pausas y extras
            if (normalizedName.includes('tenis')) return 300; // La duraci√≥n es muy variable (5 horas)
            if (normalizedName.includes('motor')) return 120; // 2 horas para otros deportes de motor
            if (normalizedName.includes('ciclismo')) return 180;
            if (normalizedName.includes('boxeo')) return 120;

            // Valor por defecto para otros eventos no clasificados (1 hora y 45 minutos)
            return 105;
        }

        

        async function processCiriacoData(html) {
    const numberedChannels = [];
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    const rows = doc.querySelectorAll('table.tabla-eventos tbody tr');
    let fechaActual = doc.querySelector('.fecha')?.innerText.trim() || 'Hoy';
    
    const channelMappings = { 'LA LIGA 1': 'La Liga', 'MOVISTAR': 'M+', 'Premier': 'Premier League', 'EUROSPORT': '‚òÖEUROSPORT', 'La Liga TV La Liga Hypermotion': 'La Liga Hypermotion', 'ACCION': 'Acci√≥n', 'CLASICOS': 'Cl√°sicos', 'Plus\\+': 'Plus', 'GOLF': 'Golf', 'VAMOS': 'Vamos', 'BALONCESTO 1': 'Baloncesto', 'M. DEPORTES ES': 'M+ Deportes', 'LALIGA': 'La Liga', 'LA LIGA': 'La Liga', 'EUROSPORT 4K': 'EUROSPORT 1' };

    const emojiMap = { 'üéæ': ['Open Australia', 'Roland Garros', 'Wimbledon', 'US Open', 'ATP', 'WTA', 'Hexagon Cup', 'Grand Slam', 'Davis Cup', 'United Cup', 'Copa Davis', 'Tenis'], '‚öΩ': ['Primera Federaci√≥n Femenina', 'FA Women\'s Super League', 'Liga F', 'Champions Femenina', 'Premier League', 'La Liga EA Sports', 'Primera Federaci√≥n', 'Serie A Italiana', 'Saudi Pro League', 'Bundesliga', 'Ligue 1', 'Eredivisie', 'Copa del Rey', 'Champions League', 'Europa League', 'Conference League', 'MLS', 'Eurocopa', 'Coppa Italia', 'Primera Divisi√≥n Argentina', 'Serie A Brasil', 'Copa Libertadores', 'Concacaf', 'FA Cup', 'Carabao Cup', 'Copa Alemania', 'Copa Francia', 'F√∫tbol', 'Futbol'], 'üèÄ': ['Liga Endesa', 'NBA', 'Liga ACB', 'Euroliga', 'Eurocup', 'NCAA Basketball', 'FIBA', 'Copa del Rey Baloncesto', 'Baloncesto'], 'üèà': ['NFL', 'NCAA Football', 'Super Bowl'], 'üèâ': ['Rugby', 'Gallagher Premiership', 'Six Nations', 'Super Rugby', 'Top 14'], '‚öæ': ['LVBP', 'MLB', 'World Baseball Classic'], 'üèçÔ∏è': ['Moto', 'MotoGP', 'WorldSBK', 'Motocross', 'MXGP', 'Supercross'], 'üèéÔ∏è': ['F1', 'Formula 1', 'IndyCar', 'Nascar', 'Rally', 'WRC', 'Dakar', 'Extreme E', 'GP', 'Carrera'], 'ü•ä': ['UFC', 'Boxeo', 'PFL', 'Bellator', 'MMA', 'K-1', 'Bare Knuckle'], 'üö¥': ['Ciclismo', 'Tour de Francia', 'Giro de Italia', 'Vuelta a Espa√±a', 'AlUla Tour', 'Paris-Roubaix', 'Challenge Mallorca', 'Volta a Catalunya'], '‚õ≥': ['Golf', 'Masters', 'PGA', 'Bahrain Championship', 'Ryder Cup', 'US Open Golf', 'The Open', 'LIV Golf'], 'ü§æ': ['EHF Europeo', 'Champions League Handball', 'Asobal', 'Liga Guerreras'], 'üèê': ['Voleibol', 'Superliga', 'VNL', 'Voley'], 'üèí': ['NHL', 'Hockey'], 'üéØ': ['Darts', 'Dardos'], 'üé±': ['Snooker', 'Billar'], '‚õµ': ['America\'s Cup', 'Vela', 'SailGP'] };

    rows.forEach(row => {
        // Actualizar fecha si la fila es un separador de d√≠a
        if (row.classList.contains('fecha')) {
            fechaActual = row.innerText.trim();
            return;
        }
        const cells = row.querySelectorAll('td');
        if (cells.length < 5) return;
        const hora = cells[0].innerText.trim();
        const comp = cells[2].innerText.trim();
        const match = cells[3].innerText.trim();
        const t1 = cells[3].querySelectorAll('img')[0]?.src || '';
        const t2 = cells[3].querySelectorAll('img')[1]?.src || '';

        let detectedEmoji = 'üèÜ';
        for (const [emoji, keywords] of Object.entries(emojiMap)) {
            if (keywords.some(key => comp.includes(key) || match.includes(key))) { detectedEmoji = emoji; break; }
        }

        const eventInfo = { time: hora, competition: comp, match: match, date: fechaActual, sportEmoji: detectedEmoji, imga: t1, imgb: t2, startTime: getEventTime(fechaActual, hora).getTime(), endTime: getEventTime(fechaActual, hora).getTime() + (120 * 60000) };

        row.querySelectorAll('a[href^="acestream://"]').forEach(link => {
            const id = link.href.split('://')[1];
            let rawName = link.innerText.trim();
            if (!rawName || rawName.includes('---') || id.length !== 40) return;

            // Normalizar nombre del canal
            for (const key in channelMappings) { 
                rawName = rawName.replace(new RegExp(key, 'gi'), channelMappings[key]); 
            }
            
            const { name, quality, multiAudio } = cleanNameAndExtractQuality(rawName);
            const uniqueEventId = `ev-crt-${id.substring(0,8)}-${fechaActual}-${hora}`.replace(/\s+/g, '_');

            // A√±adir como canal reproducible con informaci√≥n de evento vinculada
            numberedChannels.push({
                id: id,
                name: name,
                quality: quality || 'EVENTO',
                multiAudio: multiAudio,
                source: 'events',
                event: eventInfo
            });
        });
    });
    return numberedChannels;
}

        function getEventTime(dateString, timeString) {
            const now = new Date();
            const date = parseDateString(dateString, now);
            if (date.getTime() === now.getTime()) {
                date.setHours(now.getHours());
                date.setMinutes(now.getMinutes());
            }
            const [hours, minutes] = timeString.split(':').map(Number);
            const eventTime = new Date(date);
            eventTime.setHours(hours, minutes, 0, 0);
            const todayYear = now.getFullYear();
            const todayMonth = now.getMonth();
            const todayDate = now.getDate();
            if (dateString.toLowerCase() === 'hoy' || (eventTime.getDate() === todayDate && eventTime.getMonth() === todayMonth && eventTime.getFullYear() === todayYear)) {
                return eventTime;
            }
            return eventTime;
        }        async function processFutbolEnLaTvData(htmlContent) {
    const numberedChannels = [];
    const parser = new DOMParser();
    const doc = parser.parseFromString(htmlContent, 'text/html');
    let fechaEvento = "Hoy";
    
    const channelMappings = { 'LA LIGA 1': 'La Liga', 'MOVISTAR': 'M+', 'Premier': 'Premier League', 'EUROSPORT': '‚òÖEUROSPORT', 'La Liga TV La Liga Hypermotion': 'La Liga Hypermotion', 'ACCION': 'Acci√≥n', 'CLASICOS': 'Cl√°sicos', 'Plus\\+': 'Plus', 'GOLF': 'Golf', 'VAMOS': 'Vamos', 'BALONCESTO 1': 'Baloncesto', 'M. DEPORTES ES': 'M+ Deportes', 'LALIGA': 'La Liga', 'LA LIGA': 'La Liga', 'EUROSPORT 4K': 'EUROSPORT 1' };
    const emojiMap = { 'üéæ': ['Open Australia', 'Roland Garros', 'Wimbledon', 'US Open', 'ATP', 'WTA', 'Hexagon Cup', 'Grand Slam', 'Davis Cup', 'United Cup', 'Copa Davis', 'Tenis'], '‚öΩ': ['Premier League', 'La Liga', 'Champions League', 'Europa League', 'Serie A', 'Bundesliga', 'F√∫tbol', 'Futbol', 'Copa del Rey'], 'üèÄ': ['Liga Endesa', 'NBA', 'Liga ACB', 'Euroliga', 'Eurocup', 'NCAA Basketball', 'FIBA', 'Copa del Rey Baloncesto', 'Baloncesto'], 'üèéÔ∏è': ['F1', 'Formula 1', 'GP', 'Carrera'], 'üèçÔ∏è': ['MotoGP', 'Moto'], 'üö¥': ['Ciclismo', 'Tour de Francia', 'Giro', 'Vuelta'] };

    const filas = doc.querySelectorAll('.tablaPrincipal tr');
    filas.forEach(fila => {
        if (fila.classList.contains('cabeceraTabla')) {
            const fechaMatch = fila.textContent.match(/(\d{2}\/\d{2}\/\d{4})/);
            if (fechaMatch) fechaEvento = fechaMatch[1];
            return;
        }
        const horaElement = fila.querySelector('.hora');
        if (!horaElement) return;
        const hora = horaElement.textContent.trim();
        const comp = fila.querySelector('.detalles label')?.title || "Competici√≥n";
        const matchName = `${fila.querySelector('.local span')?.title || "Local"} vs ${fila.querySelector('.visitante span')?.title || "Visitante"}`;
        
        let detectedEmoji = '‚öΩ';
        for (const [emoji, keywords] of Object.entries(emojiMap)) {
            if (keywords.some(key => comp.includes(key) || matchName.includes(key))) { detectedEmoji = emoji; break; }
        }

        fila.querySelectorAll('.listaCanales li').forEach(canal => {
            let rawName = canal.textContent.replace(/\(Ver en directo\)/gi, '').replace(/\([A-Z0-9\s]+\)/gi, '').trim();
            for (const key in channelMappings) { rawName = rawName.replace(new RegExp(key, 'gi'), channelMappings[key]); }
            const { name } = cleanNameAndExtractQuality(rawName);
            const startTime = new Date(`${fechaEvento.split('/').reverse().join('-')}T${hora}:00`).getTime() || Date.now();

            numberedChannels.push({ id: `ev-ftv-${name.replace(/\s+/g, '')}-${hora.replace(':', '')}`, name: name, quality: "EVENTO", source: 'events', event: { time: hora, competition: comp, match: matchName, date: fechaEvento, sportEmoji: detectedEmoji, imga: fila.querySelector('.local img')?.src || "", imgb: fila.querySelector('.visitante img')?.src || "", startTime: startTime, endTime: startTime + (105 * 60 * 1000) } });
        });
    });
    return numberedChannels;
}

        function processEventsData(htmlContent) {
    const numberedChannels = [];
    const parser = new DOMParser();
    const doc = parser.parseFromString(htmlContent, 'text/html');
    let fechaActual = "Hoy";
    const rows = doc.querySelectorAll('tr');

    // --- Mapeos espec√≠ficos de EVENTOS ---
    const channelMappings = {
          'LA LIGA 1': 'La Liga',
          'MOVISTAR': 'M+',
          'Premier': 'Premier League',
          'EUROSPORT': '‚òÖEUROSPORT',
          'La Liga TV La Liga Hypermotion': 'La Liga Hypermotion',
          'ACCION': 'Acci√≥n',
          'CLASICOS': 'Cl√°sicos',
          'Plus\\+': 'Plus',
          'GOLF': 'Golf',
          'VAMOS': 'Vamos',
          'BALONCESTO 1': 'Baloncesto',
          'M. DEPORTES ES': 'M+ Deportes',
          'LALIGA': 'La Liga',
          'LA LIGA': 'La Liga',
          'EUROSPORT 4K': 'EUROSPORT 1'
};
    // ------------------------------------

    rows.forEach(row => {
        const dayParent = row.closest('.events-day');
        if (dayParent) {
            const h2Text = dayParent.querySelector('h2')?.innerText.trim();
            if (h2Text && h2Text.includes(' - ')) fechaActual = h2Text.split(' - ')[1].trim();
        }

        if (row.classList.contains('event-row')) {
            const cells = row.querySelectorAll('td');
            if (cells.length < 3) return;            const hora = cells[0].innerText.trim();
            let competicion = row.querySelector('.competition-name')?.innerText.trim() || "";
            let matchName = "";
            const teamNames = row.querySelectorAll('.team-name');
            const eventoNameElem = row.querySelector('.evento-name');

            if (teamNames.length >= 2) {
                matchName = teamNames[0].innerText.trim() + " vs " + teamNames[1].innerText.trim();
            } else if (eventoNameElem) {
                const eventoText = eventoNameElem.innerText.trim();
                // Caso espec√≠fico: "Jornada 3 PGA Tour"
                if (eventoText.toLowerCase().includes('jornada')) {
                    const parts = eventoText.match(/^(Jornada\s+\d+)\s+(.*)$/i);
                    if (parts) {
                        matchName = parts[1]; // "Jornada 3"
                        competicion = parts[2]; // "PGA Tour"
                    } else {
                        matchName = eventoText;
                    }
                } else {
                    matchName = eventoText;
                }
            }
            
            // Si despu√©s de todo no hay competici√≥n definida, evitamos poner "Evento"
            if (!competicion) competicion = matchName;

            const t1_logo = row.querySelectorAll('.team-logo')[0]?.src || '';
            const t2_logo = row.querySelectorAll('.team-logo')[1]?.src || '';            const emojiMap = {
                'üéæ': ['Open Australia', 'Roland Garros', 'Wimbledon', 'US Open', 'ATP', 'WTA', 'Hexagon Cup', 'Grand Slam', 'Davis Cup', 'United Cup', 'Copa Davis'],
                '‚öΩ': ['Primera Federaci√≥n Femenina', 'FA Women\'s Super League', 'Liga F', 'Champions Femenina', 'Premier League', 'La Liga EA Sports', 'Primera Federaci√≥n', 'Serie A Italiana', 'Saudi Pro League', 'Bundesliga', 'Ligue 1', 'Eredivisie', 'Copa del Rey', 'Champions League', 'Europa League', 'Conference League', 'MLS', 'Eurocopa', 'Coppa Italia', 'Primera Divisi√≥n Argentina', 'Serie A Brasil', 'Copa Libertadores', 'Concacaf', 'FA Cup', 'Carabao Cup', 'Copa Alemania', 'Copa Francia'],
                'üèÄ': ['Liga Endesa', 'NBA', 'Liga ACB', 'Euroliga', 'Eurocup', 'NCAA Basketball', 'FIBA', 'Copa del Rey Baloncesto'],
                'üèà': ['NFL', 'NCAA Football', 'Super Bowl'],
                'üèâ': ['Rugby', 'Gallagher Premiership', 'Six Nations', 'Super Rugby', 'Top 14'],
                '‚öæ': ['LVBP', 'MLB', 'World Baseball Classic'],
                'üèçÔ∏è': ['Moto', 'MotoGP', 'WorldSBK', 'Motocross', 'MXGP', 'Supercross'],
                'üèéÔ∏è': ['F1', 'Formula 1', 'IndyCar', 'Nascar', 'Rally', 'WRC', 'Dakar', 'Extreme E'],
                'ü•ä': ['UFC', 'Boxeo', 'PFL', 'Bellator', 'MMA', 'K-1', 'Bare Knuckle'],
                'üö¥': ['Ciclismo', 'Tour de Francia', 'Giro de Italia', 'Vuelta a Espa√±a', 'AlUla Tour', 'Almanshiyah Train Station', 'Trofeo Calvia', 'Winter Park', 'Paris-Roubaix', 'Liege-Bastogne-Liege', 'Milano-Sanremo', 'Trofeo Felanitx', 'Trofeo Ses Salines', 'Trofeo Pollen√ßa', 'Trofeo Palma', 'Trofeo Andratx', 'Challenge Mallorca', 'Volta a Catalunya', 'Itzulia', 'Cl√°sica San Sebasti√°n'],
                '‚õ≥': ['Golf', 'Masters', 'PGA', 'Bahrain Championship', 'Ryder Cup', 'US Open Golf', 'The Open', 'LIV Golf'],
                'ü§æ': ['EHF Europeo', 'Champions League Handball', 'Asobal', 'Liga Guerreras'],
                'üèê': ['Voleibol', 'Superliga', 'VNL', 'Voley'],
                'üèí': ['NHL', 'Hockey'],
                'üéØ': ['Darts', 'Dardos'],
                'üé±': ['Snooker', 'Billar'],
                '‚õµ': ['America\'s Cup', 'Vela', 'SailGP']
            };

            let detectedEmoji = 'üèÜ';
            for (const [emoji, keywords] of Object.entries(emojiMap)) {
                if (keywords.some(key => competicion.includes(key))) {
                    detectedEmoji = emoji;
                    break;
                }
            }

            const eventInfo = {
                time: hora,
                competition: competicion,
                match: matchName,
                date: fechaActual,
                sportEmoji: detectedEmoji,
                imga: t1_logo,
                imgb: t2_logo,
                startTime: getEventTime(fechaActual, hora).getTime(),
                endTime: getEventTime(fechaActual, hora).getTime() + (120 * 60000)
            };

            const channelElements = row.querySelectorAll('.channel-link');
            channelElements.forEach(el => {
                const rawName = el.innerText.trim();
                if (!rawName || rawName.includes('---')) return;
                let cleanedName = rawName.replace(/\s*\(.*?\)/g, '').replace(/:\s*VER PARTIDO/gi, '').replace(/\s*HDR/gi, '').trim();
                
                // Aplicar mapeo de nombre espec√≠fico de EVENTOS
                for (const key in channelMappings) {
                    const regex = new RegExp(key, 'gi');
                    if (regex.test(cleanedName)) {
                        cleanedName = cleanedName.replace(new RegExp(key, 'gi'), channelMappings[key]);
                    }
                }                // Generar una ID √∫nica basada en el nombre, fecha y hora para evitar colisiones en el merge y el filtrado
                const uniqueEventId = `event-${cleanedName}-${fechaActual}-${hora}`.replace(/\s+/g, '_');
                
                numberedChannels.push({
                    id: uniqueEventId,
                    name: cleanedName,
                    quality: 'EVENTO',
                    source: 'events',
                    event: eventInfo
                });
            });
        }
    });
    return numberedChannels;
}

        function processChannelNames() {
            const brands = [{
                name: 'M+',
                class: 'movistar'
            }, {
                name: '‚òÖEurosport',
                class: 'eurosport'
            }, {
                name: 'DAZN',
                class: 'dazn'
            }, {
                name: 'F1',
                class: 'f1'
            }, {
                name: 'Acci√≥n',
                class: 'action'
            }, {
                name: 'Deportes',
                class: 'sports'
            }, {
                name: 'Cl√°sicos',
                class: 'cinema-red'
            }, {
                name: 'Vamos',
                class: 'vamos'
            }, {
                name: 'Copa del Rey',
                class: 'copadelrey'
            }, {
                name: 'Liga de Campeones',
                class: 'champions'
            }, {
                name: 'La Liga',
                class: 'liga'
            }, {
                name: 'Hypermotion',
                class: 'hypermotion'
            }, {
                name: 'Golf',
                class: 'golf'
            }, {
                name: '‚òÖEUROSPORT\\d+',
                class: 'eurosport-number',
                regex: true
            }, {
                name: 'Smartbank',
                class: 'smartbank'
            }, {
                name: 'Plus',
                class: 'plus'
            }, {
                name: 'Western',
                class: 'western'
            }, {
                name: 'Documentales',
                class: 'documentary'
            }, {
                name: 'Originales',
                class: 'originals'
            }, {
                name: 'Hits',
                class: 'cinema-red'
            }, {
                name: 'Estrenos',
                class: 'cinema-red'
            }, {
                name: 'Indie',
                class: 'cinema-red'
            }, {
                name: 'Cine Espa√±ol',
                class: 'cinema-red'
            }, {
                name: 'Drama',
                class: 'cinema-red'
            }, {
                name: 'Ellas',
                class: 'ellas'
            }, {
                name: 'Series',
                class: 'series'
            }];
            state.channelsData.forEach(channel => {
                let result = channel.name;
                brands.forEach(brand => {
                    if (brand.regex) {
                        const regex = new RegExp(`(${brand.name})`, 'gi');
                        result = result.replace(regex, `<span class="${brand.class}">$1</span>`);
                    } else {
                        const escapedName = brand.name.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                        const regex = new RegExp(`(${escapedName})`, 'gi');
                        result = result.replace(regex, `<span class="${brand.class}">$1</span>`);
                    }
                });
                const comediaRegex = /(comedia)/gi;
                result = result.replace(comediaRegex, '<span class="degradado-comedia">Comedia</span>');
                channel.displayableName = result;
            });
        }

        function compareChannelsForSort(a, b) {
            const channelA = state.channelsData.find(c => c.id === a.id) || a;
            const channelB = state.channelsData.find(c => c.id === b.id) || b;

            const ratingA = state.channelRatings[channelA.id] !== undefined ? state.channelRatings[channelA.id] : 2.5;
            const ratingB = state.channelRatings[channelB.id] !== undefined ? state.channelRatings[channelB.id] : 2.5;

            if (ratingA !== ratingB) {
                return ratingB - ratingA;
            }

            const qualityMap = {
                'UHD': 6,
                '4K': 5,
                'FHD': 4,
                'HD': 3,
                'SD': 2,
                'N/A': 1
            };
            const qualityA = qualityMap[standardizeQuality(channelA.quality)] || 0;
            const qualityB = qualityMap[standardizeQuality(channelB.quality)] || 0;
            if (qualityB !== qualityA) {
                return qualityB - qualityA;
            }

            return channelA.name.localeCompare(channelB.name);
        }

        function getBestChannelInSubgroup(channels) {
            if (!channels || channels.length === 0) return null;

            const mainChannelName = channels[0].name.trim().toLowerCase();
            const lastPlayedId = state.lastPlayedByChannel[mainChannelName];

            if (lastPlayedId) {
                const lastPlayedChannel = channels.find(c => c.id === lastPlayedId);
                if (lastPlayedChannel) {
                    const rating = state.channelRatings[lastPlayedId] !== undefined ? state.channelRatings[lastPlayedId] : 2.5;
                    if (rating >= 3) {
                        const others = channels.filter(c => c.id !== lastPlayedId);
                        return [lastPlayedChannel, ...others].sort(compareChannelsForSort)[0];
                    }
                }
            }

            const sortedChannels = [...channels].sort((a, b) => {
                const ratingA = state.channelRatings[a.id] !== undefined ? state.channelRatings[a.id] : 2.5;
                const ratingB = state.channelRatings[b.id] !== undefined ? state.channelRatings[b.id] : 2.5;
                if (ratingA !== ratingB) {
                    return ratingB - ratingA;
                }
                if (a.isLive && !b.isLive) return -1;
                if (!a.isLive && b.isLive) return 1;
                const qualityMap = {
                    'UHD': 6,
                    '4K': 5,
                    'FHD': 4,
                    'HD': 3,
                    'SD': 2,
                    'N/A': 1
                };
                const qualityA = qualityMap[standardizeQuality(a.quality)] || 0;
                const qualityB = qualityMap[standardizeQuality(b.quality)] || 0;
                if (qualityB !== qualityA) {
                    return qualityB - qualityA;
                }
                const sourcePriorityMap = {
                    'gist': 4,
                    'era': 3,
                    'events': 2,
                    'shickat': 1,
                    'elcano': 0,
                    'history': -1
                };
                const sourceA = sourcePriorityMap[a.source] || 0;
                const sourceB = sourcePriorityMap[b.source] || 0;
                if (sourceB !== sourceA) {
                    return sourceB - sourceA;
                }
                return a.name.localeCompare(b.name);
            });
            return sortedChannels[0];
        }        function getGroupedChannels() {
            // 1. TRABAJO SOBRE COPIA LOCAL PARA EL GRID
            const allData = state.channelsData;
            const eventChannels = allData.filter(c => c.source === 'events');
            let gridData = [];

            // Procesamos la duplicaci√≥n SOLO para el array del grid
            allData.forEach(c => {
                if (c.source === 'events') {
                    gridData.push({ ...c, isLive: isChannelLive(c, []) });
                    return;
                }

                const channelNameNormalized = normalizeText(c.name);
                const matchingEvents = eventChannels.filter(e => normalizeText(e.name) === channelNameNormalized);

                if (matchingEvents.length > 0) {
                    // Duplicamos el canal para que aparezca en cada evento correspondiente en el grid
                    matchingEvents.forEach(eventChannel => {
                        gridData.push({
                            ...c,
                            event: eventChannel.event,
                            isLive: isChannelLive(c, [eventChannel])
                        });
                    });
                } else {
                    // Si no tiene eventos, aparece una sola vez como canal fijo
                    gridData.push({ ...c, isLive: isChannelLive(c, []) });
                }
            });

            // Filtramos la data local procesada para el grid
            const filteredChannels = filterChannels(gridData);
            
            // Ordenaci√≥n de calidad y fuente
            const sortedChannels = [...filteredChannels].sort((a, b) => {
                if (a.isLive && !b.isLive) return -1;
                if (!a.isLive && b.isLive) return 1;
                const qMap = { 'UHD': 6, '4K': 5, 'FHD': 4, 'HD': 3, 'SD': 2, 'N/A': 1 };
                const qDiff = (qMap[standardizeQuality(b.quality)] || 0) - (qMap[standardizeQuality(a.quality)] || 0);
                if (qDiff !== 0) return qDiff;
                const sMap = { 'gist': 4, 'era': 3, 'events': 2, 'shickat': 1, 'elcano': 0 };
                return (sMap[b.source] || 0) - (sMap[a.source] || 0) || a.name.localeCompare(b.name);
            });

            const groups = {};
            sortedChannels.forEach(channel => {
                let groupName;
                let isEventGroup = false;
                const mode = state.tvCurrentFilter;

                // AGRUPACI√ìN UNIFICADA: Si tiene evento y el filtro lo pide, van juntos s√≠ o s√≠
                if (channel.event && (mode === 'events_only' || mode === 'live' || (mode === 'search' && state.tvSearchTerm.trim() !== ''))) {
                    groupName = `${channel.event.date}###${channel.event.competition}###${channel.event.match}`;
                    isEventGroup = true;
                } else {
                    groupName = determineBrandGroup(channel);
                    isEventGroup = false;
                }

                if (!groups[groupName]) {
                    groups[groupName] = {
                        name: groupName,
                        channels: [],
                        isEvent: isEventGroup,
                        time: isEventGroup ? channel.event.time : null,
                        date: isEventGroup ? channel.event.date : null,
                        sportEmoji: isEventGroup ? channel.event.sportEmoji : null,
                        sportName: isEventGroup ? channel.event.sportName : null,
                        competition: isEventGroup ? channel.event.competition : null,
                        match: isEventGroup ? channel.event.match : null,
                        hasLive: channel.isLive
                    };
                } else {
                    if (channel.isLive) {
                        groups[groupName].hasLive = true;
                    }
                }
                groups[groupName].channels.push(channel);
            });
            Object.values(groups).forEach(group => {
                const subGroups = {};                group.channels.forEach(channel => {
                    let subGroupName = channel.name.trim();
                    if (group.name === 'Otros') {
                        const normalizedChannelName = normalizeText(channel.name);
                        let foundSubGroup = null;
                        for (const subGroupKey of OTHER_SUBGROUPS) {
                            const normalizedSubGroupKey = normalizeText(subGroupKey);
                            if (normalizedChannelName.includes(normalizedSubGroupKey)) {
                                foundSubGroup = subGroupKey;
                                break;
                            }
                        }
                        subGroupName = foundSubGroup || subGroupName;
                    }
                    if (subGroupName.includes('DAZN') && subGroupName.includes('BAR')) {
                        subGroupName = subGroupName.replace(' BAR', '').trim();
                    }
                    
                    // CLAVE DE UNICIDAD: Si no estamos en modo eventos/live, la clave es SOLO el nombre del canal.
                    // Esto evita que un mismo canal aparezca varias veces por tener varios eventos.
                    const isEventPriority = (state.tvCurrentFilter === 'events_only' || state.tvCurrentFilter === 'live');
                    const subGroupKey = (channel.event && isEventPriority) 
                        ? `${subGroupName}_${channel.event.match}_${channel.event.time}` 
                        : subGroupName;

                    if (!subGroups[subGroupKey]) {
                        subGroups[subGroupKey] = [];
                    }
                    subGroups[subGroupKey].push(channel);
                });
                group.subGroups = subGroups;
            });
            const sortedGroupKeys = Object.keys(groups).sort((a, b) => {
                const groupA = groups[a];
                const groupB = groups[b];
                const aHasLive = groupA.channels.some(c => c.isLive);
                const bHasLive = groupB.channels.some(c => c.isLive);
                if (aHasLive && !bHasLive) return -1;
                if (!aHasLive && bHasLive) return 1;
                if (groupA.isEvent && groupB.isEvent) {
                    const dateCompare = compareEventDates(groupA, groupB);
                    if (dateCompare !== 0) return dateCompare;
                    return a.localeCompare(b);
                }
                if (groupA.isEvent && !groupB.isEvent) return -1;
                if (!groupA.isEvent && groupB.isEvent) return 1;
                const indexA = groupOrder.indexOf(a);
                const indexB = groupOrder.indexOf(b);
                if (indexA === -1 && indexB === -1) {
                    return a.localeCompare(b);
                }
                if (indexA === -1) return 1;
                if (indexB === -1) return -1;
                return indexA - indexB;
            });
            if (groups['Otros']) {
                sortedGroupKeys.push(sortedGroupKeys.splice(sortedGroupKeys.indexOf('Otros'), 1)[0]);
            }
            return {
                groups,
                sortedGroupKeys
            };
        }        function filterChannels(dataToFilter = state.channelsData) {
            let filteredChannels = [...dataToFilter];
            const searchTerm = state.tvSearchTerm.trim().toLowerCase();
            let currentFilter = state.tvCurrentFilter;
            let currentSportFilter = state.tvSportFilter;

            if (currentFilter === 'search' || searchTerm !== '') {
                const term = normalizeText(searchTerm);
                
                // Mapeo inteligente de t√©rminos a Emojis de deporte
                const searchToEmoji = {
                    'futbol': '‚öΩ', 'soccer': '‚öΩ', 'balompie': '‚öΩ',
                    'baloncesto': 'üèÄ', 'basket': 'üèÄ', 'nba': 'üèÄ',
                    'tenis': 'üéæ', 'tennis': 'üéæ',
                    'f1': 'üèéÔ∏è', 'formula 1': 'üèéÔ∏è', 'motor': 'üèéÔ∏è',
                    'moto': 'üèçÔ∏è', 'motogp': 'üèçÔ∏è',
                    'ciclismo': 'üö¥', 'bici': 'üö¥',
                    'golf': '‚õ≥',
                    'boxeo': 'ü•ä', 'ufc': 'ü•ä', 'mma': 'ü•ä',
                    'nfl': 'üèà', 'futbol americano': 'üèà',
                    'rugby': 'üèâ',
                    'beisbol': '‚öæ', 'baseball': '‚öæ',
                    'balonmano': 'ü§æ', 'handball': 'ü§æ',
                    'voley': 'üèê', 'voleibol': 'üèê',
                    'hockey': 'üèí',
                    'dardos': 'üéØ',
                    'snooker': 'üé±', 'billar': 'üé±',
                    'vela': '‚õµ'
                };                // Mapeo din√°mico para reconocer t√©rminos parciales como 'fut', 'bas', etc.
                let targetEmoji = null;
                for (const [key, emoji] of Object.entries(searchToEmoji)) {
                    if (key.startsWith(term) || term.startsWith(key)) {
                        targetEmoji = emoji;
                        break;
                    }
                }

                filteredChannels = filteredChannels.filter(channel => {
                    if (searchTerm === '') return true;

                    const normalizedName = normalizeText(channel.name);
                    const normalizedId = channel.id ? channel.id.toLowerCase() : '';

                    // 1. Coincidencia por texto (Nombre e ID)
                    // Para t√©rminos muy cortos como 'F1', buscamos coincidencia m√°s precisa
                    const nameMatch = term.length <= 2 ? 
                        normalizedName.split(' ').some(word => word === term) || normalizedName.includes(term) :
                        normalizedName.includes(term);
                    
                    const idMatch = normalizedId.includes(term);
                    
                    let eventTextMatch = false;
                    if (channel.event) {
                        eventTextMatch = normalizeText(channel.event.competition || '').includes(term) || 
                                         normalizeText(channel.event.match || '').includes(term);
                    }

                    // 2. Coincidencia por deporte (Emoji)
                    const sportMatch = targetEmoji && channel.event && channel.event.sportEmoji === targetEmoji;
                    
                    return nameMatch || idMatch || eventTextMatch || sportMatch;
                });
            } else if (currentFilter === 'events_only') {
                // FILTRADO POR EVENTO (No por fuente)
                filteredChannels = filteredChannels.filter(c => c.event);
            } else if (currentFilter === 'live') {
                filteredChannels = filteredChannels.filter(c => c.isLive);
            } else if (currentFilter !== 'all' && !['events_only', 'live', 'search'].includes(currentFilter)) {
                filteredChannels = filteredChannels.filter(c => normalizeText(c.name).includes(normalizeText(currentFilter.replace('+', ''))));
            }

            if (currentSportFilter !== 'all') {
                const normalizedSportFilter = normalizeText(currentSportFilter);
                const sportSearchTerms = {};
                let targetTerms = sportSearchTerms[normalizedSportFilter] || [normalizedSportFilter];
                if (normalizedSportFilter === 'motorsport' && sportSearchTerms['f1']) {
                    targetTerms = targetTerms.concat(sportSearchTerms['f1']);
                }
                filteredChannels = filteredChannels.filter(channel => {
                    const normalizedName = normalizeText(channel.name);
                    const eventDetailsMatch = channel.event && (
                        normalizeText(channel.event.sportName || '').includes(normalizedSportFilter) ||
                        targetTerms.some(term => normalizeText(channel.event.competition || '').includes(term)) ||
                        targetTerms.some(term => normalizeText(channel.event.match || '').includes(term))
                    );
                    const nameMatch = targetTerms.some(term => normalizedName.includes(term));
                    return eventDetailsMatch || nameMatch;
                });
            }

            return filteredChannels;
        }

        function standardizeQuality(quality) {
            if (!quality) return 'SD';
            quality = quality.toLowerCase();
            if (quality.includes('uhd') || quality.includes('4k')) {
                return '4K';
            }
            if (quality.includes('1080') || quality.includes('fhd')) {
                return 'FHD';
            }
            if (quality.includes('720') || quality.includes('hd')) {
                return 'HD';
            }
            return 'SD';
        }

        function getChannelNumberFromName(name) {
            const match = name.match(/\d+/);
            return match ? parseInt(match[0], 10) : 1;
        }        function formatEventDate(dateString) {
            // Eliminamos solo lo que est√© entre par√©ntesis (la redundancia de la fuente)
            dateString = dateString.replace(/\s*\(.*?\)/g, '').trim();
            
            const normalizedDate = dateString.toLowerCase();
            const today = new Date();
            const weekdays = ['Domingo', 'Lunes', 'Martes', 'Mi√©rcoles', 'Jueves', 'Viernes', 'S√°bado'];

            // 1. Manejar "Hoy", "Ma√±ana", "Ayer"
            if (normalizedDate === 'hoy' || normalizedDate === 'ma√±ana') {
                return normalizedDate.charAt(0).toUpperCase() + normalizedDate.slice(1);
            }
            
            const date = parseDateString(dateString, today);
            if (normalizedDate === 'ayer') {
                return weekdays[date.getDay()];
            }

            // 2. Manejar formato de fecha num√©rico (Mantiene el nombre del d√≠a generado por el c√≥digo)
            const parts = dateString.split('/');
            if (parts.length >= 2 && parts.length <= 3) {
                return `${weekdays[date.getDay()]} ${dateString}`;
            }

            return dateString;
        }

        function compareEventDates(eventA, eventB) {
            const today = new Date();
            const dateStringA = eventA.date.toLowerCase();
            const dateStringB = eventB.date.toLowerCase();

            const isTodayA = dateStringA === 'hoy';
            const isTodayB = dateStringB === 'hoy';
            const isTomorrowA = dateStringA === 'ma√±ana';
            const isTomorrowB = dateStringB === 'ma√±ana';
            const isYesterdayA = dateStringA === 'ayer';
            const isYesterdayB = dateStringB === 'ayer';

            if (isTodayA && !isTodayB) return -1;
            if (!isTodayA && isTodayB) return 1;
            if (isTodayA && isTodayB) return eventA.time.localeCompare(eventB.time);

            if (isTomorrowA && !isTomorrowB) return -1;
            if (!isTomorrowA && isTomorrowB) return 1;
            if (isTomorrowA && isTomorrowB) return eventA.time.localeCompare(eventB.time);

            if (isYesterdayA && !isYesterdayB) return -1;
            if (!isYesterdayA && isYesterdayB) return 1;
            if (isYesterdayA && isYesterdayB) return eventA.time.localeCompare(eventB.time);

            const dateA = parseDateString(eventA.date, today);
            const dateB = parseDateString(eventB.date, today);

            if (dateA.getTime() !== dateB.getTime()) {
                return dateA.getTime() - dateB.getTime();
            }
            return eventA.time.localeCompare(eventB.time);
        }

        function parseDateString(dateString, today) {
            const normalizedDate = dateString.toLowerCase();
            if (normalizedDate === 'ma√±ana') {
                const tomorrow = new Date(today);
                tomorrow.setDate(today.getDate() + 1);
                return tomorrow;
            }
            if (normalizedDate === 'ayer') {
                const yesterday = new Date(today);
                yesterday.setDate(today.getDate() - 1);
                return yesterday;
            }
            const parts = dateString.split('/');
            if (parts.length >= 2 && parts.length <= 3) {
                // Asume formato DD/MM/YY o DD/MM/YYYY
                const day = parseInt(parts[0], 10);
                const month = parseInt(parts[1], 10) - 1; // Mes es 0-indexado
                let year = parts[2] ? parseInt(parts[2], 10) : today.getFullYear();

                if (parts.length === 2) {
                    year = today.getFullYear(); // Si falta el a√±o, usa el actual
                }

                if (year < 100) {
                    year = year + 2000;
                }

                const date = new Date(year, month, day);

                // Validaci√≥n b√°sica para evitar fechas inv√°lidas que JS pueda interpretar
                if (date.getDate() !== day || date.getMonth() !== month || date.getFullYear() !== year) {
                    return today;
                }

                return date;
            }
            return today;
        }

        function isChannelLive(channel, allEventChannels) {
            if (channel.source !== 'events' || !channel.event) {
                return false;
            }
            const now = new Date().getTime();
            const event = channel.event;
            const liveStartTime = event.startTime - (15 * 60 * 1000);
            const liveEndTime = event.endTime;
            const isTimeframeLive = now >= liveStartTime && now <= liveEndTime;
            if (!isTimeframeLive) {
                return false;
            }
            const isConflicted = findConflictingSiblings(channel, allEventChannels);
            if (isConflicted) {
                return false;
            }
            return true;
        }

        function findConflictingSiblings(currentChannel, allEventChannels) {
            const currentChannelName = normalizeText(currentChannel.name);
            const currentStartTime = currentChannel.event.startTime;
            const conflictingSibling = allEventChannels.find(sibling => {
                if (sibling.id === currentChannel.id || sibling.source !== 'events' || !sibling.event) {
                    return false;
                }
                const siblingChannelName = normalizeText(sibling.name);
                const siblingStartTime = sibling.event.startTime;
                const isSameChannelName = siblingChannelName === currentChannelName;
                const isScheduledLater = siblingStartTime > currentStartTime;
                if (isSameChannelName && isScheduledLater) {
                    const now = new Date().getTime();
                    const siblingLiveStartTime = siblingStartTime - (15 * 60 * 1000);
                    if (now >= siblingLiveStartTime) {
                        return true;
                    }
                }
                return false;
            });
            return !!conflictingSibling;
        }
        const groupOrder = [
            'DAZN F1',
            'DAZN',
            'DAZN La Liga',
            'DAZN Baloncesto',
            'M+ La Liga',
            'Liga de Campeones',
            'La Liga Hypermotion',
            'M+ Vamos',
            'M+ Deportes',
            'M+ Plus',
            'M+ Golf',
            'M+ Cine y Series',
            '‚òÖEUROSPORT'
        ];
        const groupRegexes = {
            'DAZN F1': /DAZN F1/i,
            'DAZN Baloncesto': /DAZN Baloncesto/i,
            'DAZN La Liga': /DAZN La Liga/i,
            'DAZN': /DAZN(?!.*F1|.*La Liga|.*Baloncesto)/i,
            'Liga de Campeones': /Liga de Campeones/i,
            'La Liga Hypermotion': /La Liga Hypermotion/i,
            'M+ La Liga': /M\+ La Liga/i,
            'M+ Vamos': /M\+ Vamos/i,
            'M+ Deportes': /M\+ Deportes/i,
            'M+ Plus': /M\+ Plus/i,
            'M+ Golf': /M\+ Golf/i,
            'M+ Cine y Series': /M\+(?!.*La Liga|.*Vamos|.*Deportes|.*Plus|.*Golf|.*Liga de Campeones)/i,
            '‚òÖEUROSPORT': /‚òÖEUROSPORT/i,
        };

        function determineBrandGroup(channel) {
            const channelName = channel.name;
            const normalizedName = normalizeText(channelName);

            if (channelName.includes('Ellas')) {
                return 'M+ Vamos';
            }

            if (channelName.includes('‚òÖEUROSPORT') && (channelName.includes('DE') || channelName.includes('PL') || channelName.includes('RU'))) {
                return 'Otros';
            }
            if (groupRegexes['DAZN'] && groupRegexes['DAZN'].test(channelName)) {
                if (normalizedName.includes('eventos') || normalizedName.includes('eleven')) {
                    return 'Otros';
                }
            }
            for (const groupName of groupOrder) {
                if (groupRegexes[groupName] && groupRegexes[groupName].test(channelName)) {
                    return groupName;
                }
            }
            return 'Otros';
        }

        function playChannel(acestreamId) {
            const acestreamUrl = `acestream://${acestreamId}`;
            const newWindow = window.open(acestreamUrl, '_blank');
            setTimeout(() => {
                if (newWindow && newWindow.closed) {} else {}
            }, 500);
        }

        function handleChannelPlay(channelToPlay) {
            if (state.lastChannelPlay) {
                updateChannelRating(state.lastChannelPlay.channelId, channelToPlay.id);
            }

            const now = new Date().getTime();
            state.lastChannelPlay = {
                channelId: channelToPlay.id,
                timestamp: now
            };
            localStorage.setItem('lastChannelPlay', JSON.stringify(state.lastChannelPlay));

            state.lastPlayedByChannel[channelToPlay.name.trim().toLowerCase()] = channelToPlay.id;
            localStorage.setItem('lastPlayedByChannel', JSON.stringify(state.lastPlayedByChannel));

            playChannel(channelToPlay.id);
        }

        function updateChannelRating(previousChannelId, currentChannelId) {
            const now = new Date().getTime();
            const previousChannelData = state.channelsData.find(c => c.id === previousChannelId);

            if (!previousChannelData) return;

            const duration = (now - state.lastChannelPlay.timestamp) / 1000;
            let rating = state.channelRatings[previousChannelId] !== undefined ? state.channelRatings[previousChannelId] : 2.5;
            let newRating = rating;

            const previousName = previousChannelData.name.toLowerCase().trim();
            const currentChannelData = state.channelsData.find(c => c.id === currentChannelId);
            const currentName = currentChannelData ? currentChannelData.name.toLowerCase().trim() : '';

            if (previousChannelId !== currentChannelId && previousName === currentName) {
                if (duration >= (30 * 60)) {
                    newRating += 1.5;
                } else if (duration >= (15 * 60)) {
                    newRating += 0.5;
                } else if (duration >= (5 * 60)) {
                    newRating -= 1;
                } else if (duration >= 10) {
                    newRating -= 1.5;
                } else {
                    newRating -= 2;
                }
            } else if (previousChannelId !== currentChannelId && previousName !== currentName) {
                if (duration >= (30 * 60)) {
                    newRating += 1.5;
                } else {
                    newRating = rating;
                }
            } else if (previousChannelId === currentChannelId) {
                return;
            }

            state.channelRatings[previousChannelId] = Math.max(1, Math.min(5, newRating));
            saveRatings();

            renderTVChannels();
        }        function showCopyModal(acestreamId) {
            const acestreamUrl = `acestream://${acestreamId}`;
            const vlcUrl = `http://vlc.shickat.me:8000/pid/${acestreamId}/stream.mp4`;
            const copyModal = document.getElementById('copyModal');
            
            document.getElementById('copyAceStreamBtn').onclick = () => copyUrlToClipboard(acestreamUrl, 'AceStream');
            document.getElementById('copyVlcBtn').onclick = () => copyUrlToClipboard(vlcUrl, 'VLC');
            
            copyModal.classList.add('active');
        }

        async function copyAcestreamDirectly(acestreamId) {
            showCopyModal(acestreamId);
        }

        function hideCopyModal() {
            document.getElementById('copyModal').classList.remove('active');
        }

        function showCopySuccessMessage(format = 'AceStream') {
            const messageElement = document.getElementById('copyMessage');
            messageElement.textContent = `${format} URL copiada con √©xito!`;
            messageElement.classList.add('show');
            setTimeout(() => {
                messageElement.classList.remove('show');
            }, 2000);
        }

        async function copyUrlToClipboard(urlToCopy, format) {
            try {
                await navigator.clipboard.writeText(urlToCopy);
                hideCopyModal();
                showCopySuccessMessage(format);
            } catch (err) {
                console.error('Error al copiar el texto: ', err);
                alert('No se pudo copiar la URL. Por favor, hazlo manualmente.');
            }
        }

        function changePrimaryColor(color) {
            state.primaryColor = color;
            const rgb = hexToRgb(color);
            document.documentElement.style.setProperty('--primary-rgb', `${rgb.r}, ${rgb.g}, ${rgb.b}`);
            document.documentElement.style.setProperty('--primary', color);
            document.documentElement.style.setProperty('--primary-dark', color === '#2563eb' ? '#1e50c7' : color);
            updatePrimaryLightColor();
            document.querySelectorAll('.color-picker .color-option').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`.color-option[data-color="${color}"]`).classList.add('active');
            localStorage.setItem('primaryColor', color);
            renderTVChannels();
        }

        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return {
                r,
                g,
                b
            };
        }

        function updatePrimaryLightColor() {
            const rgb = hexToRgb(state.primaryColor);
            const isDarkMode = true;
            document.documentElement.style.setProperty('--primary-light', isDarkMode ? `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.2)` : `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.1)`);
        }

        function cleanObsoleteRatings() {
            const activeChannelIds = new Set(state.channelsData.map(c => c.id));
            const ratingsToKeep = {};
            for (const channelId in state.channelRatings) {
                if (activeChannelIds.has(channelId)) {
                    ratingsToKeep[channelId] = state.channelRatings[channelId];
                }
            }
            state.channelRatings = ratingsToKeep;
            saveRatings();
            console.log("Puntuaciones de canales obsoletas limpiadas.");
        }

        function saveRatings() {
            localStorage.setItem('channelRatings', JSON.stringify(state.channelRatings));
        }

        function resetRatings() {
            if (confirm('¬øEst√°s seguro de que quieres restablecer todas las puntuaciones de los canales?')) {
                localStorage.removeItem('channelRatings');
                state.channelRatings = {};
                renderTVChannels();
                showStatusMessage("Puntuaciones de canales restablecidas.", "success");
                document.getElementById('settingsModal').classList.remove('modal--active');
            }
        }        function startCalibration() {
            const grouped = getGroupedChannels();
            state.calibrationQueue = [];
            
            // Crear cola: Un canal de cada subgrupo (excluyendo el grupo 'Otros')
            for (const gKey in grouped.groups) {
                if (gKey === 'Otros') continue;

                const subGroups = grouped.groups[gKey].subGroups;
                for (const sName in subGroups) {
                    const best = getBestChannelInSubgroup(subGroups[sName]);
                    if (best) state.calibrationQueue.push(best);
                }
            }

            if (state.calibrationQueue.length === 0) return alert('No hay canales para calibrar.');
            
            state.isCalibrating = true;
            document.getElementById('settingsModal').classList.remove('modal--active');
            nextCalibrationStep();
        }

        function nextCalibrationStep() {
            if (state.calibrationQueue.length === 0) {
                stopCalibration();
                alert('Calibraci√≥n finalizada.');
                return;
            }

            const channel = state.calibrationQueue[0];
            document.getElementById('calibChannelName').textContent = channel.name;
            document.getElementById('calibrationModal').classList.add('modal--active');
            playChannel(channel.id);
        }

        function processCalibration(works) {
            const channel = state.calibrationQueue.shift();
            let rating = state.channelRatings[channel.id] !== undefined ? state.channelRatings[channel.id] : 2.5;
            
            if (works) {
                state.channelRatings[channel.id] = Math.min(5, rating + 1.5);
                // Si funciona, pasamos al siguiente nombre de canal diferente (ahorramos pasos)
                nextCalibrationStep();
            } else {
                state.channelRatings[channel.id] = Math.max(1, rating - 1.5);
                // Si no funciona, buscamos si hay otro link para el mismo nombre en el total de data
                const alternatives = state.channelsData.filter(c => c.name === channel.name && c.id !== channel.id);
                if (alternatives.length > 0) {
                    // Insertar la mejor alternativa al principio de la cola para probarla ya
                    const nextBest = alternatives.sort(compareChannelsForSort)[0];
                    state.calibrationQueue.unshift(nextBest);
                }
                nextCalibrationStep();
            }
            saveRatings();
        }

        function stopCalibration() {
            state.isCalibrating = false;
            state.calibrationQueue = [];
            document.getElementById('calibrationModal').classList.remove('modal--active');
            renderTVChannels();
        }        

        function factoryReset() {
            if (confirm('‚ö†Ô∏è ¬øEST√ÅS SEGURO? Esta acci√≥n borrar√° todos tus datos, ajustes e historial. La p√°gina se recargar√° por completo.')) {
                localStorage.clear();
                window.location.reload();
            }
        }

        function getStarRating(score) {
            const fullStars = Math.floor(score);
            const hasHalfStar = score % 1 >= 0.5;
            let stars = '‚òÖ'.repeat(fullStars);
            if (hasHalfStar) {
                stars += '<span class="half-star">‚òÖ</span>';
            }
            const emptyStars = '‚òÜ'.repeat(5 - fullStars - (hasHalfStar ? 1 : 0));
            return `<span style="color: var(--primary);">${stars}</span><span style="color: gray;">${emptyStars}</span>`;
        }

        function restoreTVFilterUI() {
            clearAllTVFilterVisuals();

            if (state.tvSportFilter !== 'all') {
                const sportBtn = document.querySelector(`.tv-nav-link[data-sport-key="${state.tvSportFilter}"]`);
                if (sportBtn) {
                    sportBtn.classList.add('tv-sidebar-link-focused');
                }
            } else {
                const brandLink = document.querySelector(`.tv-nav-link[data-filter="${state.tvCurrentFilter}"]`);
                if (brandLink) {
                    brandLink.classList.add('tv-sidebar-link-focused');
                }
            }

            // Aplicar foco al bot√≥n de ajustes si es necesario (ej: al cerrar el modal de ajustes)
            const settingsBtn = document.getElementById('settingsModeBtn');
            if (settingsBtn) {
                settingsBtn.classList.remove('tv-sidebar-link-focused'); // Limpiar por si acaso
                // Se puede a√±adir l√≥gica si queremos que el bot√≥n de ajustes retenga el foco visualmente.
            }
        }

        const createTVChannelCard = (channel, allOptionsJson = '[]') => {
            const placeholderInfo = getPlaceholderInfo(channel.name.toUpperCase());
            const logoUrl = placeholderInfo ? placeholderInfo.logo : null;

            const isLiveClass = channel.isLive ? 'tv-card-live' : '';
            let bgColor = '#2d2d2d';
            let nameStyle = 'white';
            let backgroundStyle = '';            // 1. Asignar color de fondo por marca (simplificado para texto)
            const isDaznBaloncesto = channel.name.toUpperCase().includes('DAZN BALONCESTO');
            if (channel.name.includes('DAZN') && !channel.name.includes('F1')) bgColor = '#2d2d2d';
            else if (channel.name.includes('DAZN F1')) bgColor = '#2d2d2d';
            else if (channel.name.includes('M+')) bgColor = '#2d2d2d';
            else if (channel.name.includes('EUROSPORT')) bgColor = '#2d2d2d'; 
            
            if (logoUrl) {
                if (isDaznBaloncesto) {
                    backgroundStyle = `background-image: url('${logoUrl}'), radial-gradient(circle, #ff5500 100%, transparent 100%); background-position: center center, 92% center; background-size: contain, 45% 80%; background-repeat: no-repeat, no-repeat; background-origin: content-box, content-box; background-color: ${bgColor};`;
                } else {
                    backgroundStyle = `background: ${bgColor} url('${logoUrl}') center center / contain no-repeat; background-origin: content-box;`;
                }
            } else {
                // Si no hay logo, el fondo es solo el color de marca
                backgroundStyle = `background: ${bgColor};`;
            }
            let channelNameHTML = '';
            // MODIFICACI√ìN CLAVE: Si NO hay logo, hacemos visible el nombre del canal centrado en el card.
            if (!logoUrl) {
                channelNameHTML = `<div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 5px;"><h3 style="font-size: 0.6rem; font-weight: 700; color: white; white-space: normal; margin: 0; text-align: center; display: block;">${channel.displayableName}</h3></div>`;
            } else {
                let badgeContent = '';
                if (channel.name.toUpperCase().includes('VAMOS 2')) {
                    badgeContent = `<div style="position: absolute; left: 24px; top: 78%; transform: translateY(-50%); color: #1ec33c; font-weight: 900; font-size: 1.4rem; z-index: 2;">2</div>`;
                }
                channelNameHTML = `<div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; flex-direction: column; justify-content: flex-end; align-items: center; padding: 5px;">${badgeContent}<h3 style="display: none;">${channel.displayableName}</h3></div>`;
            }

            // Indicador EN VIVO eliminado por solicitud
            let liveIndicator = '';

            const isEventSource = channel.source === 'events';
            const optionsButton = isEventSource ? '' : `<button class="tv-link-button" data-channel-id="${channel.id}" title="Ver opciones alternativas">+</button>`;

            const pointerEvents = isEventSource ? 'pointer-events: none; cursor: default;' : '';
            return ` <div class="tv-card ${isLiveClass}" data-channel-id="${channel.id}" data-all-options='${allOptionsJson}' style="${backgroundStyle} ${pointerEvents}" ${isEventSource ? '' : 'tabindex="0" role="button"'} aria-label="Ver canal ${channel.name}"> ${optionsButton} ${channelNameHTML}</div> `;
        };

        function createTVChannelsHTML(groups, sortedGroupKeys) {
            if (sortedGroupKeys.length === 0) {
                // Nuevo HTML para el mensaje de no resultados, envuelto en el nuevo div para centrar
                return `
                    <div class="no-results-container">
                        <div class="no-results">
                            <div class="no-results-icon">üì°</div>
                            <div class="no-results-text">No se encontraron canales</div>
                            <div class="no-results-hint">Prueba con otros filtros o t√©rminos de b√∫squeda</div>
                        </div>
                    </div>
                `;
            }

            let html = '';
            let lastDateRendered = null;
            const isEventMode = state.tvCurrentFilter === 'events_only';
            const isAllMode = state.tvCurrentFilter === 'all';            for (const groupKey of sortedGroupKeys) {
                const group = groups[groupKey];
                const subGroups = group.subGroups;

                let cardsHTML = '';
                const sortedSubGroupNames = Object.keys(subGroups).sort((a, b) => {
                    const aHasLive = subGroups[a].some(c => c.isLive);
                    const bHasLive = subGroups[b].some(c => c.isLive);
                    if (aHasLive && !bHasLive) return -1;
                    if (!aHasLive && bHasLive) return 1;
                    return a.localeCompare(b);
                });                const renderedNamesInGroup = new Set();
                sortedSubGroupNames.forEach(subGroupName => {
                    let channels = subGroups[subGroupName];
                    if (state.hideNoLinks) {
                        channels = channels.filter(c => c.source !== 'events');
                    }
                    if (channels.length === 0) return;

                    const bestChannel = getBestChannelInSubgroup(channels);
                    if (!bestChannel) return;

                    const normalizedBestName = normalizeText(bestChannel.name);
                    if (renderedNamesInGroup.has(normalizedBestName)) return;
                    renderedNamesInGroup.add(normalizedBestName);

                    const allLinks = state.channelsData.filter(c => 
                        normalizeText(c.name) === normalizedBestName
                    );

                    const allOptions = allLinks.map(c => ({
                        id: c.id,
                        name: c.displayableName || c.name,
                        quality: standardizeQuality(c.quality),
                        multiAudio: c.multiAudio,
                        source: c.source,
                        rating: state.channelRatings[c.id] !== undefined ? state.channelRatings[c.id] : 2.5
                    }));
                    const allOptionsJson = JSON.stringify(allOptions);
                    cardsHTML += createTVChannelCard(bestChannel, allOptionsJson);
                });

                if (!cardsHTML) continue;

                if (group.isEvent) {
                    const formattedDate = formatEventDate(group.date);
                    if (formattedDate !== lastDateRendered) {
                        let prefix = 'Eventos del ';
                        let coloredDateHtml = formattedDate;
                        const parts = formattedDate.split(' ');
                        const firstWord = parts[0].toLowerCase();

                        if (firstWord === 'hoy' || firstWord === 'ma√±ana' || firstWord === 'ayer' || firstWord === 'el') {
                            prefix = 'Eventos de ';
                            if (firstWord === 'el') {
                                const dayOfWeek = parts[1];
                                const datePart = parts.slice(2).join(' ');
                                coloredDateHtml = `<span style="color: var(--primary);">el ${dayOfWeek} ${datePart}</span>`;
                            } else {
                                coloredDateHtml = `<span style="color: var(--primary);">${formattedDate}</span>`;
                            }
                        } else {
                            coloredDateHtml = `<span style="color: var(--primary);">${formattedDate}</span>`;
                        }
                        const finalTitle = (prefix === 'Eventos de ' && formattedDate.toLowerCase().startsWith('el')) ? `Eventos ${formattedDate}` : `${prefix}${formattedDate}`;
                        html += `<h2 class="tv-date-header">${finalTitle}</h2>`;
                        lastDateRendered = formattedDate;
                    }
                } else {
                    lastDateRendered = null;
                }

                let groupTitle = group.name;
                let groupTitleStyle = '';

                if (group.isEvent) {
                    const liveTimeClass = group.hasLive ? 'live-time-blink' : '';
                    const competitionHtml = `<span style="color: var(--primary);">${group.competition}</span>`;
                    const matchParts = group.match.split(' vs ');
                    const team1 = matchParts[0] || '';
                    const team2 = matchParts[1] || '';
                    const eventChannel = group.channels.find(c => c.source === 'events' && c.event);
                    const t1_logo = eventChannel?.event?.imga || '';
                    const t2_logo = eventChannel?.event?.imgb || '';
                    const logoStyle = "width:18px; height:18px; object-fit:contain; vertical-align:middle; margin:0 4px; background:white; border-radius:50%; padding:2px;";
                    const team1Html = `<span><img src="${t1_logo}" style="${logoStyle}" onerror="this.style.display='none'">${team1}</span>`;
                    const team2Html = `<span>${team2}<img src="${t2_logo}" style="${logoStyle}" onerror="this.style.display='none'"></span>`;
                    const isVsMatch = group.match.toLowerCase().includes(' vs ');
                    const vsHtml = isVsMatch ? `<span style="color:var(--primary); font-weight:bold; margin:0 5px;">VS</span>` : '';
                    groupTitle = `<div style="display: flex; flex-direction: column; align-items: flex-start;"><div style="display: flex; align-items: center; gap: 8px;"><span style="font-size: 0.75rem; line-height: 1;">${group.sportEmoji}</span> ${competitionHtml}</div><div style="display: flex; align-items: center;"><span class="${liveTimeClass}" style="margin-right: 7.5px; border-right: 2px solid var(--primary); padding-right: 7.5px; display: inline-block; line-height: 0.8; height: 0.5rem; font-size: 0.55rem;">${group.time}</span> ${team1Html} ${vsHtml} ${team2Html}</div></div>`;
                    if (!lastDateRendered || (group.date && formatEventDate(group.date) === lastDateRendered)) groupTitleStyle = 'margin-top: 0;';
                } else if (group.name.includes('###')) {
                    if (isAllMode || state.tvCurrentFilter === 'search') continue;
                    const parts = group.name.split('###');
                    if (parts.length >= 3) {
                        const competition = parts[1], match = parts[2], eventInfo = group.channels[0]?.event;
                        const sportEmoji = eventInfo?.sportEmoji || '‚ùì', time = eventInfo?.time || '';
                        const competitionHtml = `<span style="color: var(--primary);">${competition}</span>`;
                        groupTitle = `<div style="display: flex; flex-direction: column; align-items: flex-start;"><div style="display: flex; align-items: center; gap: 8px;"><span style="font-size: 1.1rem; line-height: 1;">${sportEmoji}</span> ${competitionHtml}</div><div style="display: flex; align-items: center;"><span style="margin-right: 7.5px; border-right: 2px solid var(--primary); padding-right: 7.5px; display: inline-block; line-height: 0.8; height: 0.5rem; font-size: 0.55rem;">${time}</span> ${match}</div></div>`;
                    } else groupTitle = group.name.replace(/###/g, ' - ');
                }

                html += ` <div class="tv-group"><header class="tv-group-header"><h2 class="tv-group-title" style="${groupTitleStyle}">${groupTitle}</h2></header> `; 
                html += `<div class="tv-subgroup-content">${cardsHTML}</div></div>`;
            }
            return html;
        }

        function renderTVChannels() {
            const tvGrid = document.getElementById('tvChannelsGrid');
            if (!tvGrid) return;

            const statusContainer = document.getElementById('tvStatusMessageContainer');
            if (statusContainer) {
                statusContainer.innerHTML = '';
            }

            // MODIFICACI√ìN CLAVE 1: Obtener el campo de b√∫squeda y guardar el foco y la posici√≥n del cursor
            const searchInput = document.getElementById('globalSearchInput');
            let isFocused = false;
            let cursorStart = 0;
            let cursorEnd = 0;

            if (searchInput && document.activeElement === searchInput) {
                isFocused = true;
                cursorStart = searchInput.selectionStart;
                cursorEnd = searchInput.selectionEnd;
            }

            restoreTVFilterUI();

            // MODIFICACI√ìN CLAVE 2: Mostrar/Ocultar y configurar el contenedor de b√∫squeda (NO LO RECREAMOS)
            const searchContainer = document.getElementById('searchContainer');
            const isSearchFilter = state.tvCurrentFilter === 'search';

            if (isSearchFilter) {
                searchContainer.style.display = 'flex'; // Mostrar contenedor
                searchInput.value = state.tvSearchTerm; // Asegurar el valor (aunque el listener de input ya lo hace)
                // Si estaba enfocado antes de renderizar, restaurar el foco y el cursor
                if (isFocused) {
                    searchInput.focus();
                    searchInput.setSelectionRange(cursorStart, cursorEnd);
                }
            } else {
                searchContainer.style.display = 'none'; // Ocultar contenedor
            }


            const {
                groups,
                sortedGroupKeys
            } = getGroupedChannels();
            tvGrid.innerHTML = createTVChannelsHTML(groups, sortedGroupKeys);

            // A√±adir/eliminar la clase de centrado si no hay canales
            if (sortedGroupKeys.length === 0) {
                tvGrid.classList.add('no-channels');
            } else {
                tvGrid.classList.remove('no-channels');
            }

            attachTVCardEvents();

            // L√≥gica de Focus Manager (mantenida por completitud, pero la restauraci√≥n de b√∫squeda ya est√° arriba)
            if (state.tvFocusManager) {
                state.tvFocusManager.updateFocusableElements();

                // Si no es el modo b√∫squeda y hay que restaurar el foco a otros elementos...
                if (!isSearchFilter) {
                    const previouslyFocusedElement = state.tvFocusManager.currentFocus;
                    // Prioridad 2: Mantener el foco si estaba en un elemento a√∫n presente (e.g., bot√≥n de ajustes).
                    if (previouslyFocusedElement && document.body.contains(previouslyFocusedElement)) {
                        state.tvFocusManager.setFocus(previouslyFocusedElement);
                        return;
                    }

                    // Prioridad 3 (NUEVO): Enfocar el filtro activo en la barra lateral.
                    let elementToFocus = null;
                    const activeSportFilterLink = document.querySelector(`.tv-nav-link.sport-filter.tv-sidebar-link-focused`);
                    const activeBrandLink = document.querySelector(`.tv-nav-link[data-filter="${state.tvCurrentFilter}"].tv-sidebar-link-focused`);

                    elementToFocus = activeSportFilterLink || activeBrandLink;

                    if (elementToFocus) {
                        state.tvFocusManager.setFocus(elementToFocus);
                        return;
                    }

                    // Fallback: Enfocar 'Todos'
                    state.tvFocusManager.setFocus(document.querySelector('.tv-nav-link[data-filter="all"]'));
                } else if (isFocused) {
                    // Si estamos en modo b√∫squeda, aseguramos que el focus manager no se interfiera si ya restauramos el foco
                    state.tvFocusManager.setFocus(searchInput);
                }
            }
        }
        const attachTVCardEvents = () => {
            const cards = document.querySelectorAll('.tv-card');
            cards.forEach(card => {
                card.removeEventListener('click', handleTVCardPlay);
                card.addEventListener('click', handleTVCardPlay);
                const optionsButton = card.querySelector('.tv-link-button');
                // IMPORTANTE: Aseguramos que el evento del bot√≥n SIEMPRE est√© asociado
                if (optionsButton) {
                    optionsButton.removeEventListener('click', handleTVCardOptionsClick);
                    optionsButton.addEventListener('click', handleTVCardOptionsClick);
                }
            });
        };

        const handleTVCardPlay = (e) => {
            if (e.target.closest('.tv-link-button')) {
                // Si se hace clic en el bot√≥n de opciones, no hacer play
                return;
            }
            const card = e.currentTarget;
            const channelId = card.getAttribute('data-channel-id');
            const channel = state.channelsData.find(c => c.id === channelId);

            if (!channel || channel.source === 'events') return;

            const optionsJson = card.getAttribute('data-all-options');
            let allOptions = [];
            try {
                allOptions = JSON.parse(optionsJson);
            } catch (error) {
                console.error("Error al parsear opciones para TV Card:", error);
                handleChannelPlay(channel);
                return;
            }

            const now = new Date().getTime();
            const RECENT_FAILURE_THRESHOLD_MS = 40 * 60 * 1000;
            let channelToPlay = channel;
            let statusMessage = '';

            if (state.lastChannelPlay &&
                state.lastChannelPlay.channelId === channel.id &&
                (now - state.lastChannelPlay.timestamp) < RECENT_FAILURE_THRESHOLD_MS) {

                const sortedOptions = allOptions
                    .map(opt => state.channelsData.find(c => c.id === opt.id))
                    .filter(c => c)
                    .sort(compareChannelsForSort);

                const alternativeChannel = sortedOptions[1];

                if (alternativeChannel) {
                    channelToPlay = alternativeChannel;

                    statusMessage = `‚ùå Fallo detectado en ${channel.name}. Abriendo alternativa: ${alternativeChannel.name} (${standardizeQuality(alternativeChannel.quality)}).`;
                    showStatusMessage(statusMessage, 'error');

                } else {
                    statusMessage = `‚ö†Ô∏è ${channel.name} ha fallado de nuevo. Sin alternativas. Reintentando...`;
                    showStatusMessage(statusMessage, 'warning');
                }
            }

            if (state.copyLinkMode) {
                copyAcestreamDirectly(channelToPlay.id);
            } else {
                handleChannelPlay(channelToPlay);
            }
        }

        const handleTVCardOptionsClick = (e) => {
            e.stopPropagation();
            const card = e.currentTarget.closest('.tv-card');
            const channelId = card.getAttribute('data-channel-id');
            const optionsJson = card.getAttribute('data-all-options');
            const channel = state.channelsData.find(c => c.id === channelId);
            if (channel && optionsJson) {
                try {
                    const allOptions = JSON.parse(optionsJson);
                    showTvOptionsModal(channel.name, allOptions);
                } catch (error) {
                    console.error("Error al parsear las opciones del canal:", error);
                    handleChannelPlay(channel);
                }
            }
        };        function showTvOptionsModal(mainChannelName, optionsList) {
            const modal = document.getElementById('tvChannelOptionsModal');
            const nameSpan = document.getElementById('tvModalChannelName');
            const listDiv = document.getElementById('tvModalChannelList');
            
            const matchedChannel = state.channelsData.find(c => c.name === mainChannelName);
            nameSpan.innerHTML = matchedChannel ? matchedChannel.displayableName : mainChannelName;
            listDiv.innerHTML = '';

            const lastPlayedId = state.lastPlayedByChannel[mainChannelName.trim().toLowerCase()];

            // FILTRO ANTIDUPLICADOS INDEPENDIENTE PARA EL MODAL (POR ID DE ACESTREAM)
            const uniqueOptionsMap = new Map();
            optionsList.forEach(opt => {
                // Permitir 'events' si el ID tiene la longitud de un hash AceStream (40)
                if (!opt.id || (opt.source === 'events' && opt.id.length !== 40)) return;
                
                const cleanId = opt.id.trim().toLowerCase();
                if (!uniqueOptionsMap.has(cleanId)) {
                    uniqueOptionsMap.set(cleanId, opt);
                } else {
                    const existing = uniqueOptionsMap.get(cleanId);
                    const lpId = lastPlayedId ? lastPlayedId.trim().toLowerCase() : '';
                    if (cleanId === lpId || opt.rating > existing.rating) {
                        uniqueOptionsMap.set(cleanId, opt);
                    }
                }
            });

            const finalOptions = Array.from(uniqueOptionsMap.values()).sort((a, b) => {
                const lpId = lastPlayedId ? lastPlayedId.trim().toLowerCase() : '';
                const aId = a.id.trim().toLowerCase();
                const bId = b.id.trim().toLowerCase();

                const aIsLast = aId === lpId && a.rating >= 2.5;
                const bIsLast = bId === lpId && b.rating >= 2.5;
                if (aIsLast && !bIsLast) return -1;
                if (!aIsLast && bIsLast) return 1;

                if (b.rating !== a.rating) return b.rating - a.rating;
                const qMap = { 'UHD': 6, '4K': 5, 'FHD': 4, 'HD': 3, 'SD': 2, 'N/A': 1 };
                return (qMap[b.quality] || 0) - (qMap[a.quality] || 0) || a.name.localeCompare(b.name);
            });

            const renderOptionItem = (option) => {
                const isLastViewed = option.id === lastPlayedId;
                const lastViewedIndicator = isLastViewed ? '<span class="last-viewed-indicator">üëÅÔ∏è</span>' : '';
                const ratingStars = getStarRating(option.rating);
                let bClass = '';
                switch(option.source){ case 'gist':bClass='gist-source-color';break; case 'elcano':bClass='elcano-source-color';break; case 'shickat':bClass='shickat-badge';break; case 'era':bClass='era-source-color';break; default:bClass='channel-name-color'; }

                const clickAction = state.copyLinkMode ? `copyAcestreamDirectly('${option.id}')` : `handleChannelPlay({ id: '${option.id}', name: '${mainChannelName.replace(/'/g, "\\'")}' })`;
                
                const sourceText = option.source === 'elcano' ? 'ELC' : option.source.toUpperCase();

                return `<div class="channel-option-item" onclick="${clickAction}"><div class="channel-option-name-container">${lastViewedIndicator}<span class="channel-option-name" style="font-family: monospace; font-size: 0.45rem; color: var(--primary) !important;">${option.id.substring(0, 8)}</span></div><div class="channel-option-details"><span style="color: var(--${bClass}); font-weight: 700;">${sourceText}</span><span style="font-weight: 700; color: var(--primary); border-left: 1px solid #444; padding-left: 3px; margin-left: 3px;">${option.quality}</span><span style="margin-left: 3px;">${ratingStars}</span></div></div>`;
            };

            listDiv.innerHTML = finalOptions.map(renderOptionItem).join('');
            modal.classList.add('modal--active');
        }

        function closeTvOptionsModal() {
            document.getElementById('tvChannelOptionsModal').classList.remove('modal--active');
        }

        function setupSearchInputListener() {
            const searchInput = document.getElementById('globalSearchInput');
            const searchLupa = document.getElementById('clearSearchLupa');
            if (searchInput) {
                searchInput.removeEventListener('input', handleSearchInput);
                searchInput.addEventListener('input', handleSearchInput);
            }
            if (searchLupa) {
                searchLupa.onclick = () => {
                    state.tvSearchTerm = '';
                    if (searchInput) searchInput.value = '';
                    renderTVChannels();
                    if (searchInput) searchInput.focus();
                };
            }
        }

        // Nueva funci√≥n para manejar el input de b√∫squeda
        function handleSearchInput(e) {
            state.tvSearchTerm = e.target.value;
            // Asegurar que el filtro de b√∫squeda est√° activo y el de deporte inactivo
            state.tvCurrentFilter = 'search';
            state.tvSportFilter = 'all';
            localStorage.setItem('tvCurrentFilter', 'search');
            localStorage.setItem('tvSportFilter', 'all');

            // Renderiza la lista de canales sin recrear el input de b√∫squeda
            renderTVChannels();
        }

        function initializeTVMode() {
            // Asignar eventos de la barra lateral
            document.querySelectorAll('#tvSidebar .tv-nav-link').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const filter = link.getAttribute('data-filter');
                    const sportKey = link.getAttribute('data-sport-key');
                    if (filter) {
                        applyTVFilter(filter, 'brand');
                    } else if (sportKey) {
                        applyTVFilter(sportKey, 'sport');
                    }
                });
            });

            // Asignar eventos del modal de ajustes y copiado
            document.getElementById('settingsModeBtn').addEventListener('click', (e) => {
                e.preventDefault();
                document.getElementById('settingsModal').classList.add('modal--active');
            });

            // Cerrar modales al hacer clic fuera del contenido
            document.querySelectorAll('.modal').forEach(modal => {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.classList.remove('modal--active');
                        if (modal.id === 'calibrationModal') stopCalibration();
                    }
                });
            });
            document.getElementById('closeSettingsBtn').addEventListener('click', () => {
                document.getElementById('settingsModal').classList.remove('modal--active');
            });

            document.getElementById('devModeTrigger').addEventListener('click', () => {
                state.devClickCount++;
                if (state.devClickCount === 5) {
                    document.querySelectorAll('.dev-option').forEach(el => el.style.display = 'flex');
                    showStatusMessage("Modo desarrollador activado", "success");
                }
            });
            document.getElementById('cancelCopyBtn').addEventListener('click', hideCopyModal);
            document.getElementById('closeTvOptionsBtn').addEventListener('click', closeTvOptionsModal);

            // Inicializar checkboxes de ajustes
            document.getElementById('fullScreenOnClickCheckbox').checked = state.fullScreenOnClick;
            document.getElementById('hideOptionsButtonCheckbox').checked = state.hideOptionsButton;            document.getElementById('copyLinkModeCheckbox').checked = state.copyLinkMode;
            document.getElementById('hideNoLinksCheckbox').checked = state.hideNoLinks;
            document.getElementById('eventSourceSelect').value = state.tvEventSource;
            document.body.classList.toggle('hide-options-button-active', state.hideOptionsButton);

            // Asignar eventos a los ajustes
            document.getElementById('fullScreenOnClickCheckbox').addEventListener('change', toggleFullScreenOnClick);
            document.getElementById('hideOptionsButtonCheckbox').addEventListener('change', toggleHideOptionsButton);
            document.getElementById('copyLinkModeCheckbox').addEventListener('change', toggleCopyLinkMode);
            document.getElementById('hideNoLinksCheckbox').addEventListener('change', toggleHideNoLinks);

            // Nuevo: Activar pantalla completa al hacer clic en cualquier parte del cuerpo, si la opci√≥n est√° activa
            document.body.addEventListener('click', (e) => {
                // Evitar activar si se hace clic dentro de un modal, la barra lateral o elementos interactivos
                if (e.target.closest('.modal') || e.target.closest('#tvSidebar') || e.target.closest('a') || e.target.closest('button') || e.target.closest('input')) {
                    return;
                }

                if (state.fullScreenOnClick) {
                    requestFullScreen();
                }
            });

            // Asignar eventos de los botones de color
            document.querySelectorAll('.color-picker .color-option').forEach(btn => {
                btn.addEventListener('click', () => {
                    changePrimaryColor(btn.getAttribute('data-color'));
                });
            });

            // Aplicar color principal inicial
            changePrimaryColor(state.primaryColor);

            // **MODIFICACI√ìN CLAVE**: Adjuntar el listener de b√∫squeda solo una vez al iniciar
            setupSearchInputListener();

            // Cargar datos y renderizar
            loadInitialChannels();

            // Limpieza de historial y focus manager (si lo est√°s usando)
            cleanupOldFirstSeenRecords();
        }

        // L√≥gica del Web Worker para procesamiento en segundo plano
const workerCode = `
    self.onmessage = function(e) {
        const { task, data, extra } = e.data;
        if (task === 'processChannels') {
            const processed = data.map(channel => {
                let name = channel.name.replace(/(\\(|\\)|-->.*$)/g, '').trim();
                const quality = (q => {
                    if (!q) return 'SD'; q = q.toLowerCase();
                    if (q.includes('uhd') || q.includes('4k')) return '4K';
                    if (q.includes('1080') || q.includes('fhd')) return 'FHD';
                    if (q.includes('720') || q.includes('hd')) return 'HD';
                    return 'SD';
                })(name);
                
                name = name.replace(/1080P|1080|720P|720|UHD|FHD|HD|SD|MultiAudio|Multi Audio|Multi|multi|4K/gi, '')
                           .replace(/\\(ES\\)|\\(Es\\)|(Estable|New Era I|New Era II|New Loop|New Era VI|F√≥rmula 1|BAR|eleven|eventos)/gi, '')
                           .replace(/\\s+/g, ' ').trim();
                
                return { ...channel, name, quality };
            });
            self.postMessage({ task: 'channelsProcessed', data: processed });
        }
    };
`;

const blob = new Blob([workerCode], { type: 'application/javascript' });
worker = new Worker(URL.createObjectURL(blob));

worker.onmessage = function(e) {
    if (e.data.task === 'channelsProcessed') {
        state.channelsData = e.data.data;
        processChannelNames();
        renderTVChannels();
        document.body.classList.add('loading-finished');
    }
};

document.addEventListener('DOMContentLoaded', initializeTVMode);
    </script>
</body>

</html>