<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=0.7 maximum-scale=0.8, user-scalable=no">
    <title>üÖ∞Ô∏è</title>
    <style>
      :root {
        --primary: #2563eb;
        --primary-light: rgba(37, 99, 235, 0.1);
        --primary-dark: #1e50c7;
        --bg-light: #f1f5f9;
        --card-bg: #ffffff;
        --text: #1e293b;
        --border-color: #e2e8f0;
        --white: #ffffff;
        --radius-md: 10px;
        --radius-sm: 6px;
        --shadow-sm: 0 1px 3px rgba(0,0,0,0.1);
        --primary-rgb: 37, 99, 235;
        --secondary: #f72585;
        --success: #4cc9f0;
        --warning: #f8961e;
        --info: #4895ef;
        --movistar-blue: #0085C1;
        --eurosport-blue: #5e17eb;
        --dazn-black: #000000;
        --f1-red:#ff3535;
        --channel-name-color: #888888;
        --action-red: #ff544d;
        --classics-red: #fa3732;
        --sports-green: #11a45b;
        --vamos-green: #1fc23d;
        --copadelrey-green: #449653;
        --champions-teal: #52c29c;
        --liga-teal: #21ffb8;
        --hypermotion-cyan: #04d2d7;
        --golf-teal: #4ee1b0;
        --eurosport-number-red: #ff3535;
        --gist-source-color: #2d077d;
        --elcano-source-color: #7d070e;
        --special-gist-color: #9c27b0;
        --events-source-color: #074f7d;
        --shickat-badge: #077b3b;
        --player-bg: black;
        --channel-number-color: #4b5563;
        --plus-blue: #3399ff;
        --western-red: #e60000;
        --documentary-purple: #a06cf5;
        --originals-blue: #3985b0;
        --hits-red: #fa3732;
        --premieres-red: #fa3934;
        --indie-red: #fa3732;
        --spanish-film-red: #fa3732;
        --drama-red: #fa3732;
        --ellas-green: #35fd9b;
        --series-orange: #ff8c1f;
      }
      
      body.dark-mode {
        --bg-light: #131313;
        --card-bg: #333436;
        --text: #f8fafc;
        --border-color: #555555;
        --shadow-sm: 0 1px 3px rgba(0,0,0,0.3);
        --primary-light: rgba(var(--primary-rgb), 0.2);
        --channel-name-color: #e2e2ff;
        --player-bg: #1e1e1e;
        --channel-number-color: #b0b0b0;
      }
      
      body {
        background: var(--bg-light);
        color: var(--text);
        font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
        line-height: 1.6;
        margin: 0;
        padding: 0;
        transition: all 0.3s;
      }
      
      .main-container {
        max-width: 1400px;
        margin: 1rem auto;
        padding: 0 1rem;
      }
      
      .search-filters {
        background: var(--card-bg);
        border-radius: var(--radius-md);
        padding: 1rem;
        margin-bottom: 1rem;
        box-shadow: var(--shadow-sm);
        display: flex;
        flex-direction: column;
      }
      
      .search-box {
        position: relative;
        margin-bottom: 0.8rem;
      }
      
      .search-box input {
        width: 100%;
        padding: 0.6rem 1rem 0.6rem 2.2rem;
        border: 1px solid var(--border-color);
        border-radius: var(--radius-sm);
        font-size: 0.9rem;
        background-color: var(--card-bg);
        color: var(--text);
        box-sizing: border-box;
      }
      
      .search-box::before {
        content: "üîç";
        position: absolute;
        left: 0.8rem;
        top: 50%;
        transform: translateY(-50%);
        color: var(--text);
        font-size: 0.9rem;
      }
      
      .filter-buttons {
        display: flex;
        gap: 0.6rem;
        margin-top: 0.8rem;
        flex-wrap: wrap;
        align-items: center;
      }
      
      .filter-button {
        flex: 1;
        padding: 0.5rem;
        border: 1px solid var(--border-color);
        border-radius: var(--radius-sm);
        background: var(--card-bg);
        color: var(--text);
        cursor: pointer;
        font-size: 0.8rem;
        font-weight: 500;
        transition: all 0.2s;
        display: flex;
        justify-content: center;
        align-items: center;
        white-space: nowrap; 
      }
      
      .filter-button:hover {
        border-color: var(--primary);
      }
      
      .filter-button--active {
        background: var(--primary);
        color: white;
        border-color: var(--primary);
      }
      
      .filter-button--favorites, .filter-button--clear {
        flex: 0 0 auto;
        width: 36px;
        min-width: 36px;
        padding: 0.5rem 0;
      }

      #filterDAZN, #filterMovistar, #filterEurosport {
          flex: 1;
      }
      
      #sportFiltersContainer {
        margin-top: 0.6rem; 
        /* --- MODIFICACI√ìN CLAVE --- */
        display: flex;
        gap: 0.6rem;
        flex-wrap: wrap;
        justify-content: center; /* Centra los botones de deporte */
        /* -------------------------- */
      }
      
      /* REGLAS: Botones de filtro de deportes (emoji) redondos */
      .sport-filter-button {
        flex: 0 0 auto; 
        width: 36px;
        height: 36px;
        padding: 0;
        border-radius: 50%; 
        font-size: 1.1rem; 
      }

      .channels-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 1rem;
        align-items: flex-start;
      }
      
      .channel-card {
          background: var(--card-bg);
          border: 1px solid var(--border-color);
          border-radius: var(--radius-md);
          padding: 0.5rem 1rem 1rem 1rem;
          cursor: pointer;
          box-shadow: var(--shadow-sm);
          transition: all 0.2s;
          position: relative;
          overflow: hidden;
          display: flex;
          flex-direction: column;
          align-items: center;
          text-align: center;
      }
      
      .channel-card:hover {
          transform: translateY(-3px);
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
          border-color: var(--primary-light);
      }

      .channel-card--favorite-mode {
          border-style: dashed;
          border-width: 2px;
          border-color: var(--primary);
          opacity: 0.8;
          transition: all 0.3s ease;
      }

      .channel-card .channel-header {
          display: flex;
          justify-content: center;
          align-items: center;
          margin-bottom: 0.5rem;
          width: 100%;
      }

      .channel-name {
          font-weight: 600;
          flex-grow: 1;
          text-align: center;
          font-size: 1rem;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
          padding: 0 0.5rem;
      }

      .channel-info-line {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-top: 0.5rem;
          font-size: 0.8rem;
          color: #6b7280;
      }
      
      body.dark-mode .channel-info-line {
          color: #a0a0a0;
      }
      
      .channel-card--favorite {
        border: 2px solid var(--primary);
      }

      .channel-group {
        background: var(--card-bg);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-md);
        padding: 0;
        margin-bottom: 1rem;
        box-shadow: var(--shadow-sm);
      }
      
      .channel-group__header {
        padding: 0.8rem 1rem;
        background: var(--primary-light);
        border-bottom: 1px solid var(--border-color);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .channel-group__title {
        font-weight: 600;
        color: var(--text);
        font-size: 1rem;
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        text-align: left;
        width: 100%;
      }

      .channel-group__title > div {
        margin: 0;
        padding: 0;
      }
      
      .channel-group__content {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 0.8rem;
        padding: 0.8rem;
      }
      
      .offline-message {
        background: #fef2f2;
        color: #dc2626;
        padding: 0.5rem;
        border-radius: var(--radius-sm);
        margin-bottom: 1rem;
        text-align: center;
      }
      
      .update-notification {
        color: var(--primary);
        background: var(--primary-light);
        padding: 0.5rem;
        border-radius: var(--radius-sm);
        margin-bottom: 1rem;
        text-align: center;
        font-weight: 600;
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.5s ease, opacity 0.5s ease, margin 0.5s ease;
        opacity: 0;
        margin: 0;
      }
      
      .update-notification--show {
        max-height: 100px;
        opacity: 1;
        margin-bottom: 1rem;
      }
      
      .loading-spinner {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(0, 0, 0, 0.1);
        border-radius: 50%;
        border-top-color: var(--primary);
        animation: spin 1s ease-in-out infinite;
        margin-left: 10px;
      }
      
      .loading-container {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 10px;
        padding: 10px;
        background: var(--card-bg);
        border-radius: var(--radius-sm);
        margin-bottom: 1rem;
      }
      
      .no-results {
        grid-column: 1 / -1;
        text-align: center;
        padding: 2rem;
        background: var(--card-bg);
        border-radius: var(--radius-md);
        box-shadow: var(--shadow-sm);
        margin-top: 1rem;
      }
      
      .no-results-icon {
        font-size: 3rem;
        margin-bottom: 1rem;
        opacity: 0.5;
      }
      
      .no-results-text {
        font-size: 1.1rem;
        color: var(--text);
        margin-bottom: 0.5rem;
      }
      
      .no-results-hint {
        font-size: 0.9rem;
        color: var(--text);
        opacity: 0.7;
      }

      .modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.5);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 1001;
      }
      
      .modal--active {
        display: flex;
      }
      
      .modal__content {
        background: var(--card-bg);
        border-radius: var(--radius-md);
        padding: 1.2rem;
        width: 90%;
        max-width: 350px;
        box-shadow: var(--shadow-sm);
      }
      
      .modal__title {
        margin-bottom: 0.8rem;
        color: var(--text);
        font-size: 1.1rem;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      .modal__actions {
        display: flex;
        justify-content: flex-end;
        gap: 0.6rem;
        margin-top: 1rem;
      }
      
      .modal__btn {
        padding: 0.5rem 0.8rem;
        border: none;
        border-radius: var(--radius-sm);
        cursor: pointer;
        font-weight: 500;
        font-size: 0.9rem;
        transition: all 0.2s;
      }
      
      .modal__btn--primary {
        background: var(--primary);
        color: white;
      }
      
      .modal__btn--primary:hover {
        background: var(--primary-dark);
      }

      .settings-section {
        margin-bottom: 1.2rem;
        padding-bottom: 1rem;
        border-bottom: 1px solid var(--border-color);
      }
      
      .settings-section:last-child {
        border-bottom: none;
        margin-bottom: 0;
        padding-bottom: 0;
      }
      
      .settings-section__title {
        font-size: 0.9rem;
        color: var(--primary);
        margin-bottom: 0.8rem;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      .settings-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.8rem;
        padding: 0.5rem;
        border-radius: var(--radius-sm);
        transition: background 0.2s;
      }
      
      .settings-item:hover {
        background: var(--primary-light);
      }
      
      .settings-item__info {
        display: flex;
        align-items: center;
        gap: 12px;
        flex: 1;
      }
      
      .settings-icon {
        font-size: 1.2rem;
      }
      
      .settings-label {
        font-size: 0.9rem;
        color: var(--text);
        font-weight: 500;
        display: block;
      }
      
      .settings-description {
        font-size: 0.75rem;
        color: var(--text);
        opacity: 0.7;
        display: block;
        margin-top: 2px;
      }
      
      .settings-switch {
        position: relative;
        display: inline-block;
        width: 50px;
        height: 24px;
      }
      
      .settings-switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }
      
      .settings-slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: .4s;
        border-radius: 24px;
      }
      
      .settings-slider:before {
        position: absolute;
        content: "";
        height: 16px;
        width: 16px;
        left: 4px;
        bottom: 4px;
        background-color: white;
        transition: .4s;
        border-radius: 50%;
      }
      
      input:checked + .settings-slider {
        background-color: var(--primary);
      }
      
      input:checked + .settings-slider:before {
        transform: translateX(26px);
      }

      .color-picker {
        display: flex;
        gap: 6px;
      }
      
      .color-option {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        border: 2px solid transparent;
        cursor: pointer;
        transition: transform 0.2s;
      }
      
      .color-option:hover {
        transform: scale(1.1);
      }
      
      .color-option.active {
        border-color: var(--text);
        transform: scale(1.1);
      }

      .header {
        display: none;
      }

      .movistar { color: var(--movistar-blue) !important; }
      .eurosport { color: var(--eurosport-blue) !important; }
      .dazn { color: var(--dazn-black) !important; }
      .f1 { color: var(--f1-red) !important; }
      .action { color: var(--action-red) !important; }
      .classics { color: var(--classics-red) !important; }
      .sports { color: var(--sports-green) !important; }
      .vamos { color: var(--vamos-green) !important; }
      .copadelrey { color: var(--copadelrey-green) !important; }
      .champions { color: var(--champions-teal) !important; }
      .liga { color: var(--liga-teal) !important; }
      .hypermotion { color: var(--hypermotion-cyan) !important; }
      .golf { color: var(--golf-teal) !important; }
      .eurosport-number { color: var(--eurosport-number-red) !important; }
      .smartbank { color: var(--smartbank-red) !important; }
      .plus { color: var(--plus-blue) !important; }
      .western { color: var(--western-red) !important; }
      .documentary { color: var(--documentary-purple) !important; }
      .originals { color: var(--originals-blue) !important; }
      .hits { color: var(--hits-red) !important; }
      .premieres { color: var(--premieres-red) !important; }
      .indie { color: var(--indie-red) !important; }
      .spanish-film { color: var(--spanish-film-red) !important; }
      .drama { color: var(--drama-red) !important; }
      .ellas { color: var(--ellas-green) !important; }
      .series { color: var(--series-orange) !important; }
      
      .channel-meta {
          display: flex;
          align-items: center;
          gap: 8px;
          font-size: 0.8rem;
          color: var(--text);
          opacity: 0.7;
          position: absolute;
          bottom: 5px;
          right: 1rem;
          z-index: 10;
      }

      .channel-meta .quality-audio {
          white-space: nowrap;
      }

      .source-badge {
          font-size: 0.6rem;
          font-weight: bold;
          padding: 0.2rem 0.4rem;
          border-radius: 3px;
          z-index: 1;
      }
      
      .gist-badge { background-color: var(--gist-source-color); color: white; }
      .elcano-badge { background-color: var(--elcano-source-color); color: white; }
      .special-gist-badge { background-color: var(--special-gist-color); color: white; }
      .events-badge { background-color: var(--events-source-color); color: white; }
      .shickat-badge { background-color: var(--shickat-badge); color: white; }
      
      .channel-number-badge {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        right: 10px;
        padding: 4px;
        border-radius: 20%;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        line-height: 1;
        transition: background-color 0.3s ease;
        
        width: 30px;
        height: 30px;
      }

      .channel-number-badge .channel-number {
        font-weight: 600;
        white-space: nowrap;
        color: var(--text);
        font-size: 0.75rem;
      }

      .channel-number-badge .source-initials {
        font-size: 0.6rem;
        font-weight: bold;
        color: white;
        margin-top: 2px;
      }
      
      body.dark-mode .channel-number-badge .channel-number {
        color: white;
      }

      .retry-button {
          padding: 0.5rem 1rem;
          margin-top: 10px;
          background-color: var(--warning);
          color: white;
          border: none;
          border-radius: var(--radius-sm);
          cursor: pointer;
      }

      .status-message {
          grid-column: 1 / -1;
          text-align: center;
          padding: 0.5rem;
          font-size: 0.85rem;
          background-color: rgba(76, 201, 240, 0.1);
          border-radius: var(--radius-sm);
          margin-bottom: 0.5rem;
          opacity: 1;
          transition: all 0.5s ease-in-out, margin 0.5s ease-in-out;
      }
      
      .status-message.hide {
          opacity: 0;
          transform: translateY(-20px);
          pointer-events: none;
          margin-bottom: 0;
      }
      
      .status-message.success {
          color: var(--primary);
          background-color: var(--primary-light);
      }

      .status-message.info {
          color: var(--primary);
          background-color: var(--primary-light);
      }
      
      .status-message.error {
          color: var(--secondary);
          background-color: rgba(247, 37, 133, 0.1);
      }
      
      .status-message.warning {
          color: var(--warning);
          background-color: rgba(248, 150, 30, 0.1);
      }
      
      @keyframes spin {
        to { transform: rotate(360deg); }
      }

      @media (max-width: 768px) {
        .channels-grid {
          grid-template-columns: 1fr;
        }
        
        .filter-buttons {
          flex-wrap: wrap;
        }
        
        .channel-group__content {
          grid-template-columns: 1fr;
        }
      }
      
      @media (min-width: 768px) {
        .channels-grid {
          grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
        }
        
        .channel-name {
          font-size: 1.1rem;
        }
      }

      .floating-btn {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background-color: var(--primary);
        color: white;
        font-size: 1.5rem;
        border: none;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        cursor: pointer;
        display: flex;
        justify-content: center;
        align-items: center;
        transition: all 0.3s ease;
        z-index: 1000;
      }

      .floating-btn:hover {
        background-color: var(--primary-dark);
        transform: scale(1.05);
      }

      .floating-btn.active {
        animation: pulse 1.5s infinite ease-in-out;
        background-color: #ff544d;
      }

      @keyframes pulse {
        0% { transform: scale(1); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); }
        50% { transform: scale(1.1); box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); }
        100% { transform: scale(1); box-shadow: 0 4-4px 8px rgba(0, 0, 0, 0.2); }
      }

      .degradado-comedia {
        background-image: linear-gradient(to right, #ff3c3c, #ffa500);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        font-weight: bold;
      }
      
      .copy-modal {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: var(--card-bg);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-md);
        padding: 1.5rem;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        z-index: 2000;
        width: 90%;
        max-width: 320px;
        display: none;
        flex-direction: column;
        align-items: center;
        text-align: center;
        animation: fadeIn 0.3s ease-out;
      }
      
      .copy-modal.active {
        display: flex;
      }

      .copy-modal-icon {
        font-size: 2.5rem;
        margin-bottom: 0.8rem;
      }

      .copy-modal-text {
        font-size: 0.95rem;
        color: var(--text);
        margin-bottom: 1rem;
      }

      .copy-modal-button {
        padding: 0.6rem 1.2rem;
        background: var(--primary);
        color: white;
        border: none;
        border-radius: var(--radius-sm);
        cursor: pointer;
        font-size: 0.9rem;
        font-weight: 600;
        transition: background 0.2s;
        margin-bottom: 0.5rem;
      }

      .copy-modal-button:hover {
        background: var(--primary-dark);
      }

      .copy-modal-url {
        background-color: var(--bg-light);
        color: var(--text);
        padding: 0.5rem;
        margin-bottom: 1rem;
        border-radius: var(--radius-sm);
        font-family: monospace;
        word-break: break-all;
        font-size: 0.85rem;
      }
      
      body.dark-mode .copy-modal-url {
        background-color: var(--border-color);
      }

      @keyframes fadeIn {
        from { opacity: 0; transform: translate(-50%, -60%); }
        to { opacity: 1; transform: translate(-50%, -50%); }
      }

      .copy-message {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: var(--primary);
        color: white;
        padding: 0.6rem 1.2rem;
        border-radius: var(--radius-sm);
        font-size: 0.9rem;
        z-index: 2001;
        opacity: 0;
        transition: opacity 0.4s ease-in-out;
      }

      .copy-message.show {
        opacity: 1;
      }

      .rating-stars {
          position: absolute;
          bottom: 5px;
          left: 1rem;
          font-size: 0.9rem;
      }

      .half-star {
        background: linear-gradient(to right, var(--primary) 50%, gray 50%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        display: inline-block;
      }

      .channel-card__quality {
          font-size: 0.7rem;
          font-weight: 600;
          color: var(--primary);
          background: var(--primary-light);
          padding: 0.2rem 0.5rem;
          border-radius: var(--radius-sm);
          position: absolute;
          top: 5px;
          left: 5px;
          z-index: 10;
      }
      
      .new-channel-indicator {
        position: absolute;
        top: 8px;
        right: 8px;
        width: 8px;
        height: 8px;
        background-color: var(--primary);
        border-radius: 50%;
        animation: blink-soft 1.5s infinite ease-in-out;
        z-index: 20;
      }
      
      body.dark-mode .new-channel-indicator {
        background-color: var(--primary);
      }

      @keyframes blink-soft {
        0%, 100% {
          opacity: 1;
          transform: scale(1);
        }
        50% {
          opacity: 0.5;
          transform: scale(0.8);
        }
      }

      .event-date {
        font-size: 0.75rem;
        color: var(--primary);
        background-color: var(--primary-light);
        padding: 0.2rem 0.5rem;
        border-radius: var(--radius-sm);
        margin-top: 0.3rem;
        display: inline-block;
      }
      
      .group-title-emoji {
        font-size: 1.2em;
        vertical-align: middle;
      }
      
      .group-title-text {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
      }
      
      .marquee-container {
        width: 100%;
        overflow: hidden;
        white-space: nowrap;
        box-sizing: border-box;
      }

      .competition-text {
        display: inline-block;
        font-weight: bold;
        color: var(--primary);
      }

      .competition-text.is-overflowing {
        padding-left: 100%;
        animation: marquee 15s linear infinite;
      }
      
      body.dark-mode .competition-text {
        color: var(--primary);
      }

      @keyframes marquee {
        0% {
          transform: translate(0, 0);
        }
        100% {
          transform: translate(-100%, 0);
        }
      }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="player-section" id="playerSection" style="display: none;">
            <div class="player-container" id="playerContainer">
                <iframe id="videoFrame" allowfullscreen></iframe>
                <iframe id="scheduleFrame" allowfullscreen></iframe>
            </div>
            <div class="player-controls" id="playerControls">
                <span class="channel-info" id="channelInfo"></span>
                <button class="control-btn" id="prevChannelBtn" title="Canal anterior">‚óÑ</button>
                <button class="control-btn" id="nextChannelBtn" title="Canal siguiente">‚ñ∫</button>
                <button class="control-btn" id="toggleStickyBtn" title="Fijar reproductor">‚õä</button>
                <button class="control-btn" id="favoriteBtn" title="Guardar favorito">‚òÖ</button>
                <button class="control-btn" id="closePlayerBtn" title="Cerrar">√ó</button>
                <span class="channel-number-display" id="channelNumberDisplay"></span>
            </div>
        </div>
        
        <div class="search-filters">
            <div class="search-box">
                <input type="text" id="searchInput" placeholder="Buscar canales, n√∫mero (ej: #123)" autofocus>
            </div>
            <div class="filter-buttons">
                <button class="filter-button filter-button--favorites" id="filterFavorites">‚òÖ</button>
                <button class="filter-button" id="filterDAZN">DAZN</button>
                <button class="filter-button" id="filterMovistar">MOVISTAR+</button>
                <button class="filter-button" id="filterEurosport">‚òÖEUROSPORT</button>
                <button class="filter-button filter-button--clear" id="clearEmojiFilters">x</button>
            </div>
            <div class="filter-buttons" id="sportFiltersContainer" style="margin-top: 0.6rem;">
                <button class="filter-button sport-filter-button" data-sport-key="futbol" id="filterFutbol">‚öΩ</button>
                <button class="filter-button sport-filter-button" data-sport-key="baloncesto" id="filterBaloncesto">üèÄ</button>
                <button class="filter-button sport-filter-button" data-sport-key="tenis" id="filterTenis">üéæ</button>
                <button class="filter-button sport-filter-button" data-sport-key="boxeo" id="filterBoxeo">ü•ä</button>
                <button class="filter-button sport-filter-button" data-sport-key="ciclismo" id="filterCiclismo">üö¥</button>
                <button class="filter-button sport-filter-button" data-sport-key="motorsport" id="filterMotorsport">üèÅ</button>
                <button class="filter-button sport-filter-button" data-sport-key="f1" id="filterF1">üèéÔ∏è</button>
            </div>
            </div>

        <div id="updateNotification" class="update-notification"></div>
        <div class="channels-grid" id="channelsGrid">
            <div class="loading-container">
                <div class="loading-spinner"></div>
                <span>Cargando canales...</span>
            </div>
        </div>
    </div>
    
    <div class="modal" id="settingsModal">
        <div class="modal__content">
            <h3 class="modal__title">‚öôÔ∏è Ajustes</h3>
            
            <div class="settings-section">
                <h4 class="settings-section__title">üé® Apariencia</h4>
                
                <div class="settings-item">
                    <div class="settings-item__info">
                        <span class="settings-icon">üåì</span>
                        <div>
                            <span class="settings-label">Modo oscuro</span>
                            <span class="settings-description">Cambia entre tema claro y oscuro</span>
                        </div>
                    </div>
                    <label class="settings-switch">
                        <input type="checkbox" id="darkModeCheckbox">
                        <span class="settings-slider"></span>
                    </label>
                </div>
                
                <div class="settings-item">
                    <div class="settings-item__info">
                        <span class="settings-icon">üé®</span>
                        <div>
                            <span class="settings-label">Color principal</span>
                            <span class="settings-description">Elige un color para la interfaz</span>
                        </div>
                    </div>
                    <div class="color-picker">
                        <button class="color-option" data-color="#2563eb" style="background:#2563eb"></button>
                        <button class="color-option" data-color="#dc2626" style="background:#dc2626"></button>
                        <button class="color-option" data-color="#16a34a" style="background:#16a34a"></button>
                        <button class="color-option" data-color="#9333ea" style="background:#9333ea"></button>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <h4 class="settings-section__title">üîß Datos</h4>
                
                <div class="settings-item">
                    <div class="settings-item__info">
                        <span class="settings-icon">‚≠ê</span>
                        <div>
                            <span class="settings-label">Restablecer puntuaciones</span>
                            <span class="settings-description">Borra la puntuaci√≥n de estabilidad de todos los canales</span>
                        </div>
                    </div>
                    <button class="modal__btn" onclick="resetRatings()">Reiniciar</button>
                </div>
            </div>
            
            <div class="modal__actions">
                <button class="modal__btn modal__btn--primary" id="closeSettingsBtn">Cerrar</button>
            </div>
        </div>
    </div>
    
    <div class="copy-modal" id="copyModal">
        <div class="copy-modal-icon">üîó</div>
        <div class="copy-modal-text">¬øQuieres copiar la URL de este canal?</div>
        <p id="copyUrlDisplay" class="copy-modal-url"></p>
        <button class="copy-modal-button" id="confirmCopyBtn">Copiar enlace</button>
        <button class="modal__btn modal__btn--cancel" id="cancelCopyBtn">Cancelar</button>
    </div>

    <div class="copy-message" id="copyMessage">URL copiada con √©xito!</div>
    
    <script>
      const state = {
          allChannels: [],
          channelsData: [],
          currentFilter: 'all',
          searchTerm: '',
          favorites: JSON.parse(localStorage.getItem('favorites')) || [],
          channelHistory: JSON.parse(localStorage.getItem('channelHistory')) || {},
          currentChannel: null,
          clearButtonClickCount: 0,
          lastClearButtonClickTime: 0,
          isOnline: navigator.onLine,
          elcanoRetries: 0,
          eventsRetries: 0,
          darkMode: localStorage.getItem('darkMode') !== 'false',
          primaryColor: localStorage.getItem('primaryColor') || '#2563eb',
          isFavoriteMode: false,
          
          channelRatings: JSON.parse(localStorage.getItem('channelRatings')) || {},
          lastChannelPlay: JSON.parse(localStorage.getItem('lastChannelPlay')) || null,
          firstSeen: JSON.parse(localStorage.getItem('firstSeen')) || {},
          
          // NUEVA PROPIEDAD PARA EL FILTRO DE DEPORTES
          sportFilter: 'all' 
      };

      const RANGES = {
          NE: { start: 1, end: 249, source: 'gist' },
          EC: { start: 250, end: 499, source: 'elcano' },
          EV: { start: 500, end: 749, source: 'events' },
          SH: { start: 750, end: 999, source: 'shickat' }
      };

      const PROXIES = [
          'https://api.allorigins.win/raw?url=',
          'https://cors-anywhere.herokuapp.com/',
          'https://api.codetabs.com/v1/proxy/?quest='
      ];
      const GIST_URL = "https://gist.githubusercontent.com/Ciento20/f7847e86d06e5011706fa76f2dab90be/raw";
      const ELCANO_URL = 'https://ipfs.io/ipns/elcano.top';
      const EVENTS_URL = 'https://ciriaco-liart.vercel.app/';
      const SHICKAT_URL = 'https://shickat.me/';

      const BACKUP_KEYS = {
          gist: 'gist_channels_backup',
          elcano: 'elcano_channels_backup',
          events: 'events_channels_backup',
          shickat: 'shickat_channels_backup'
      };
      
      const MAX_RETRIES = 3;
      const BACKUP_EXPIRY_HOURS = 6;
      const HISTORY_EXPIRY_HOURS = 168;
      
      // Funci√≥n auxiliar para normalizar texto (eliminar tildes y convertir a min√∫sculas)
      function normalizeText(text) {
          if (!text) return '';
          return text.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
      }

      function trackFirstSeen(channelId) {
          if (!state.firstSeen[channelId]) {
              state.firstSeen[channelId] = new Date().getTime();
              localStorage.setItem('firstSeen', JSON.stringify(state.firstSeen));
          }
      }

      function isChannelNew(channelId) {
          const firstSeenTime = state.firstSeen[channelId];
          if (!firstSeenTime) {
              return false;
          }
          const tenMinutesInMs = 10 * 60 * 1000;
          return (new Date().getTime() - firstSeenTime) < tenMinutesInMs;
      }

      function cleanupOldFirstSeenRecords() {
          const oneWeekInMs = 7 * 24 * 60 * 60 * 1000;
          const now = new Date().getTime();
          for (const channelId in state.firstSeen) {
              if ((now - state.firstSeen[channelId]) > oneWeekInMs) {
                  delete state.firstSeen[channelId];
              }
          }
          localStorage.setItem('firstSeen', JSON.stringify(state.firstSeen));
      }

      function toggleFavorite(channelId) {
          const index = state.favorites.indexOf(channelId);
          if (index > -1) {
              state.favorites.splice(index, 1);
          } else {
              state.favorites.push(channelId);
          }
          localStorage.setItem('favorites', JSON.stringify(state.favorites));
          renderResults();
      }

      function toggleDarkMode() {
        state.darkMode = !state.darkMode;
        localStorage.setItem('darkMode', state.darkMode);
        document.body.classList.toggle('dark-mode', state.darkMode);
        document.getElementById('darkModeCheckbox').checked = state.darkMode;
        updatePrimaryLightColor();
      }
      
      // MODIFICACI√ìN DE applyFilter para filtros de marca
      function applyFilter(filter) {
        state.currentFilter = filter;
        document.getElementById('searchInput').value = '';
        state.searchTerm = '';
        
        // Desactivar filtros de marca
        document.querySelectorAll('.filter-buttons:first-of-type .filter-button').forEach(btn => btn.classList.remove('filter-button--active'));
        
        const targetBtn = document.getElementById(`filter${filter.charAt(0).toUpperCase() + filter.slice(1)}`);
        if (targetBtn) {
            targetBtn.classList.add('filter-button--active');
        } else if (filter === 'all') {
            document.getElementById('clearEmojiFilters').classList.add('filter-button--active');
        }
        
        renderResults();
      }
      
      // NUEVA FUNCI√ìN para filtros de deporte
      function applySportFilter(sportKey) {
          state.sportFilter = state.sportFilter === sportKey ? 'all' : sportKey; // Alterna el filtro
          document.getElementById('searchInput').value = '';
          state.searchTerm = '';
          
          // Quitar activaci√≥n de todos los botones de deporte
          document.querySelectorAll('.sport-filter-button').forEach(btn => btn.classList.remove('filter-button--active'));
          
          if (state.sportFilter !== 'all') {
              document.querySelector(`.sport-filter-button[data-sport-key="${sportKey}"]`).classList.add('filter-button--active');
          }

          renderResults();
      }
      
      function showStatusMessage(message, type = "info") {
          let statusElement = document.querySelector(".status-message");
          
          if (!statusElement) {
              statusElement = document.createElement("div");
              statusElement.className = "status-message";
              const channelsGrid = document.getElementById("channelsGrid");
              channelsGrid.prepend(statusElement);
          }
          
          statusElement.textContent = message;
          statusElement.className = `status-message ${type}`;

          statusElement.classList.remove('hide');

          if (type === "success" || type === "info") {
            setTimeout(() => {
                statusElement.classList.add('hide');
                statusElement.addEventListener('transitionend', () => {
                    if (statusElement.classList.contains('hide')) {
                        statusElement.remove();
                    }
                }, { once: true });
            }, 3000); 
          }
      }
      
      function saveBackup(data, key) {
          try {
              localStorage.setItem(key, JSON.stringify({ timestamp: new Date().getTime(), data }));
          } catch (e) {
              console.error(`Error al guardar la copia de seguridad para ${key}:`, e);
          }
      }

      function loadBackup(key) {
          try {
              const backupData = localStorage.getItem(key);
              if (backupData) {
                  const { timestamp, data } = JSON.parse(backupData);
                  const backupAgeHours = (new Date().getTime() - timestamp) / (1000 * 60 * 60);
                  
                  if (backupAgeHours > BACKUP_EXPIRY_HOURS) {
                      localStorage.removeItem(key);
                      return null;
                  }
                  return data;
              }
          } catch (e) {
              console.error(`Error al cargar la copia de seguridad para ${key}:`, e);
          }
          return null;
      }
      
      function mergeChannels(channelsArray) {
        const eventChannels = channelsArray.filter(channel => channel.source === 'events');
        const otherChannels = channelsArray.filter(channel => channel.source !== 'events');

        const eventIds = new Set(eventChannels.map(channel => channel.id));

        const uniqueOtherChannelsMap = new Map();
        
        const orderedOtherSources = ['gist', 'shickat', 'elcano'];

        orderedOtherSources.forEach(source => {
            otherChannels.forEach(channel => {
                if (channel.source === source) {
                    if (!eventIds.has(channel.id)) {
                        uniqueOtherChannelsMap.set(channel.id, channel);
                    }
                }
            });
        });
        
        const mergedOtherChannels = Array.from(uniqueOtherChannelsMap.values());
        
        return eventChannels.concat(mergedOtherChannels);
      }
      
      async function fetchAndProcessSource(sourceName, url, processor, backupKey) {
          let channels = null;
          let message = '';
          
          try {
              channels = await processor(url);
              saveBackup(channels, backupKey);
              message = `Canales de ${sourceName} cargados.`;
          } catch (error) {
              console.error(`Fallo al cargar de ${sourceName}:`, error);
              channels = loadBackup(backupKey);
              if (channels) {
                  message = `Fallo de ${sourceName}. Mostrando canales del historial.`;
              } else {
                  message = `Fallo de ${sourceName}. Sin historial disponible.`;
              }
          }
          return { name: sourceName, channels, message };
      }

      function loadAndRenderBackupChannels() {
          let allBackupChannels = [];
          let hasBackup = false;

          // Cargar y combinar copias de seguridad de todas las fuentes
          for (const key in BACKUP_KEYS) {
              const backup = loadBackup(BACKUP_KEYS[key]);
              if (backup) {
                  allBackupChannels = allBackupChannels.concat(backup.map(c => ({
                      ...c,
                      source: key, 
                      name: c.name || `Canal de ${key.toUpperCase()}`,
                      id: c.id || `${key}_${Math.random()}`,
                      displayableName: c.displayableName || c.name 
                  })));
                  hasBackup = true;
              }
          }

          if (allBackupChannels.length > 0) {
              const newChannels = mergeChannels(allBackupChannels); 
              state.channelsData = newChannels;
              processChannelNames(); 
              renderResults();
              
              // [MODIFICACI√ìN] Ya no mostramos la notificaci√≥n de uso de historial aqu√≠
              return true;
          }
          return false;
      }

      async function loadInitialChannels() {
          const channelsGrid = document.getElementById("channelsGrid");
          
          // 1. Mostrar historial si est√° disponible (silenciosamente)
          const isShowingBackup = loadAndRenderBackupChannels();

          // 2. Si no hay historial, mostrar spinner de carga inicial
          if (!isShowingBackup) {
              channelsGrid.innerHTML = '<div class="loading-container"><div class="loading-spinner"></div><span>Cargando canales...</span></div>';
          }
          
          // Muestra un mensaje temporal de carga. Se ocultar√° solo (showStatusMessage usa 'info').
          const temporaryLoadMessage = isShowingBackup 
            ? "Mostrando historial. Obteniendo datos en tiempo real..." 
            : "Cargando datos en tiempo real...";
          showStatusMessage(temporaryLoadMessage, "info");


          // 3. Iniciar la carga de todas las fuentes en l√≠nea
          const results = await Promise.allSettled([ 
              fetchAndProcessSource('events', EVENTS_URL, loadEventsSource, BACKUP_KEYS.events),
              fetchAndProcessSource('gist', GIST_URL, loadGistChannels, BACKUP_KEYS.gist),
              fetchAndProcessSource('shickat', SHICKAT_URL, loadShickatChannels, BACKUP_KEYS.shickat),
              fetchAndProcessSource('elcano', ELCANO_URL, loadElcanoSource, BACKUP_KEYS.elcano)
          ]);
          
          // 4. Procesar resultados
          let allChannels = [];
          let hasFallback = false; 
          let hasOnlineSuccess = false; 
          
          results.forEach(result => {
              if (result.status === 'fulfilled' && result.value.channels) {
                  if (result.value.message.includes('historial')) {
                      hasFallback = true;
                      allChannels = allChannels.concat(result.value.channels);
                  } else {
                      allChannels = allChannels.concat(result.value.channels);
                      hasOnlineSuccess = true;
                  }
              }
          });
          
          // 5. Determinar el conjunto final de canales y la √öNICA notificaci√≥n final
          if (allChannels.length > 0) {
              const newChannels = mergeChannels(allChannels);
              state.channelsData = newChannels;
              processChannelNames();
              renderResults(); 
              cleanObsoleteRatings();
              // document.getElementById('offlineMessage').style.display = 'none'; // REFERENCIA ELIMINADA

              // Notificaci√≥n √öNICA FINAL
              if (hasOnlineSuccess) {
                if (hasFallback) {
                    showStatusMessage("Canales actualizados (algunos con historial).", "warning");
                } else {
                    showStatusMessage("Canales actualizados correctamente.", "success");
                }
              } else if (hasFallback) {
                  // Esto solo ocurre si todo fall√≥ online, pero se ten√≠a un backup completo
                  showStatusMessage("Fallo al actualizar. Se sigue mostrando el historial completo.", "error");
              } else {
                   // Fallo completo, pero el arreglo tiene canales (caso l√≠mite)
                   showStatusMessage("Error al actualizar, se cargaron canales desconocidos.", "error");
              }
          } else if (isShowingBackup) {
              // Fallo en la carga online, pero ya se hab√≠a renderizado el backup
              showStatusMessage("Fallo al actualizar canales. Se sigue mostrando el historial.", "error");
          } else {
              // Fallo total y no hay backup.
              channelsGrid.innerHTML = `
                  <div class="no-results">
                      <div class="no-results-icon">üì°</div>
                      <div class="no-results-text">Error al cargar los canales.</div>
                      <div class="no-results-hint">No se han conseguido cargar los canales (modo offline/sin historial).</div>
                      <button class="retry-button" onclick="loadInitialChannels()">Reintentar</button>
                  </div>
              `;
              showStatusMessage("Error al cargar canales. Sin historial disponible.", "error");
          }
      }

      function normalizeChannelName(name) {
          if (name.includes('Eurosport 1')) {
              return '‚òÖEUROSPORT 1';
          } else if (name.includes('Eurosport 2')) {
              return '‚òÖEUROSPORT 2';
          } else if (name.includes('Eurosport')) {
              return '‚òÖEUROSPORT 1';
          } else if (name.includes('Teledeporte')) {
              return 'Teledeporte';
          }
          return name;
      }

      async function loadGistChannels() {
          const infoResponse = await fetch(GIST_URL);
          if (!infoResponse.ok) throw new Error("Error al obtener la info de canales Gist");
          const infoContent = await infoResponse.text();
          return processGistData(infoContent);
      }
      
      function processGistData(infoCanales) {
        const numberedChannels = [];
        const lines = infoCanales.split('\n').filter(line => line.trim() !== '');

        let currentNumber = RANGES.NE.start;
        const channelMappings = {
          'MOVISTAR': 'M+',
          'CLASICOS': 'Cl√°sicos',
          'VAMOS': 'Vamos',
          'ACCION': 'Acci√≥n',
          'LALIGA': 'La Liga',
          'DEPORTES': 'Deportes',
          'PLUS': 'Plus',
          'LIGA DE CAMPEONES': 'M+ Liga de Campeones',
          'GOLF': 'Golf',
          'LA LIGA': 'La Liga',
          'HYPERMOTION': 'La Liga Hypermotion',
          'EUROSPORT': '‚òÖEUROSPORT',
        };

        for (let i = 0; i < lines.length; i += 2) {
            const nameLine = lines[i].trim();
            const idLine = lines[i + 1] ? lines[i + 1].trim() : '';

            if (nameLine.includes('-->') && idLine.length > 0) {
                let namePart = nameLine.split('-->')[0].trim().toUpperCase();
                const acestreamId = idLine.replace(/p$/, '');

                if (acestreamId.length === 40) {
                    let quality = 'SD'; 
                    let multiAudio = false;

                    if (namePart.includes('FHD')) {
                        quality = 'FHD';
                        namePart = namePart.replace('FHD', '').trim();
                    } else if (namePart.includes('4K')) {
                        quality = '4K';
                        namePart = namePart.replace('4K', '').trim();
                    } else if (namePart.includes('HD')) {
                        quality = 'HD';
                        namePart = namePart.replace('HD', '').trim();
                    } else if (namePart.includes('SD')) {
                        quality = 'SD';
                        namePart = namePart.replace('SD', '').trim();
                    }
                    
                    if (namePart.includes('MULTI')) {
                        multiAudio = true;
                        namePart = namePart.replace('MULTI', '').trim();
                    }

                    let simplifiedName = namePart;
                    for (const key in channelMappings) {
                      if (simplifiedName.includes(key)) {
                          simplifiedName = simplifiedName.replace(key, channelMappings[key]);
                      }
                    }

                    numberedChannels.push({
                        id: acestreamId,
                        number: (currentNumber++).toString(),
                        name: simplifiedName,
                        quality: quality,
                        multiAudio: multiAudio,
                        isKnown: true,
                        source: 'gist'
                    });
                    trackFirstSeen(acestreamId);
                }
            }
        }
        return numberedChannels;
      }

      async function loadElcanoSource() {
          let lastError;
          for (const proxy of PROXIES) {
              try {
                  const proxyUrl = proxy + encodeURIComponent(ELCANO_URL);
                  const controller = new AbortController();
                  const timeoutId = setTimeout(() => controller.abort(), 15000);
                  const response = await fetch(proxyUrl, { signal: controller.signal });
                  clearTimeout(timeoutId);
                  if (!response.ok) throw new Error(`Proxy ${proxy} responded with ${response.status}`);
                  const htmlContent = await response.text();
                  const jsonMatch = htmlContent.match(/const linksData\s*=\s*({[\s\S]*?});/);
                  if (!jsonMatch) throw new Error("Data format changed");
                  const linksData = JSON.parse(jsonMatch[1]
                      .replace(/\s*\/\/.*(?:\n|$)/g, '')
                      .replace(/,\s*}/g, '}')
                      .replace(/,\s*]/g, ']'));
                  return processElcanoData(linksData.links || []);
              } catch (error) {
                  lastError = error;
                  console.warn(`Proxy ${proxy} failed:`, error);
                  continue;
              }
          }
          throw lastError || new Error("All proxies failed");
      }

      async function loadEventsSource() {
          let lastError;
          for (const proxy of PROXIES) {
              try {
                  const proxyUrl = proxy + encodeURIComponent(EVENTS_URL);
                  const controller = new AbortController();
                  const timeoutId = setTimeout(() => controller.abort(), 15000);
                  const response = await fetch(proxyUrl, { signal: controller.signal });
                  clearTimeout(timeoutId);
                  if (!response.ok) throw new Error(`Proxy ${proxy} responded with ${response.status}`);
                  const htmlContent = await response.text();
                  return processEventsData(htmlContent);
              } catch (error) {
                  lastError = error;
                  console.warn(`Proxy ${proxy} failed:`, error);
                  continue;
              }
          }
          throw lastError || new Error("All proxies failed for events source");
      }
      
      async function loadShickatChannels() {
          let lastError;
          for (const proxy of PROXIES) {
              try {
                  const proxyUrl = proxy + encodeURIComponent(SHICKAT_URL);
                  const controller = new AbortController();
                  const timeoutId = setTimeout(() => controller.abort(), 15000);
                  const response = await fetch(proxyUrl, { signal: controller.signal });
                  clearTimeout(timeoutId);
                  if (!response.ok) throw new Error(`Proxy ${proxy} responded with ${response.status}`);
                  const htmlContent = await response.text();
                  return processShickatData(htmlContent);
              } catch (error) {
                  lastError = error;
                  console.warn(`Proxy ${proxy} failed:`, error);
                  continue;
              }
          }
          throw lastError || new Error("All proxies failed for shickat.me");
      }

      function processShickatData(htmlContent) {
          const numberedChannels = [];
          const parser = new DOMParser();
          const doc = parser.parseFromString(htmlContent, 'text/html');
          const cards = doc.querySelectorAll('article.canal-card');
          
          let currentNumber = RANGES.SH.start;
          
          const nameMappings = {
              'Movistar': 'M+',
              'Clasicos': 'Cl√°sicos',
              'Accion': 'Acci√≥n',
              'Deportes': 'Deportes',
              'Plus': 'Plus',
              'Liga de Campeones': 'Liga de Campeones',
              'Golf': 'Golf',
          };
          
          cards.forEach(card => {
              const nameElement = card.querySelector('.canal-nombre');
              const acestreamLinkElement = card.querySelector('.acestream-link');
              
              if (nameElement && acestreamLinkElement) {
                  const rawName = nameElement.textContent.trim();
                  const acestreamId = acestreamLinkElement.textContent.trim();
                  
                  if (acestreamId.length === 40) {
                      let quality = '720p';
                      let simplifiedName = rawName;

                      if (rawName.includes('(HD)')) {
                          quality = '720p';
                          simplifiedName = rawName.replace('(HD)', '').trim();
                      } else if (rawName.includes('(FHD)')) {
                          quality = '1080p';
                          simplifiedName = simplifiedName.replace('(FHD)', '').trim();
                      }
                      
                      const multiAudio = simplifiedName.includes('MultiAudio');
                      
                      for (const key in nameMappings) {
                          if (simplifiedName.includes(key)) {
                              simplifiedName = simplifiedName.replace(key, nameMappings[key]);
                              break; 
                          }
                      }

                      if (simplifiedName.includes('M. LaLiga')) {
                          simplifiedName = simplifiedName.replace('M. LaLiga', 'M+ La Liga');
                      } else if (simplifiedName.includes('Movistar')) {
                          simplifiedName = simplifiedName.replace('Movistar', 'M+');
                      }

                      if (simplifiedName.includes('LaLiga')) {
                          simplifiedName = simplifiedName.replace('LaLiga', 'La Liga');
                      }
                      
                      simplifiedName = normalizeChannelName(simplifiedName);
                      
                      numberedChannels.push({
                          id: acestreamId,
                          number: currentNumber.toString(),
                          name: simplifiedName,
                          quality: quality,
                          multiAudio: multiAudio,
                          isKnown: true,
                          source: 'shickat'
                      });
                      trackFirstSeen(acestreamId);
                      
                      currentNumber++;
                  }
              }
          });
          
          return numberedChannels;
      }

      function processElcanoData(links) {
          const numberedChannels = [];
          let currentNumber = RANGES.EC.start;

          const nameMap = {
              'M. LaLiga': 'M+ La Liga',
              'LaLiga Smartbank': 'La Liga Hypermotion',
              'LaLiga': 'La Liga',
              'MovistarPlus': 'M+ Plus',
              'Vamos': 'M+ Vamos',
              'Deporte': 'M+ Deportes',
              'Dedporte': 'M+ Deportes',
              'Dazn': 'DAZN',
              'Campeones': 'M+ Liga de Campeones'
          };

          links.forEach(link => {
              if (link.url && link.url.startsWith('acestream://')) {
                  const acestreamId = link.url.split('://')[1];

                  let quality = '720p';
                  let multiAudio = false;

                  if (link.name.includes('1080')) quality = '1080p';
                  if (link.name.includes('720')) quality = '720p';
                  if (link.name.includes('UHD')) quality = 'UHD';

                  multiAudio = link.name.includes('MultiAudio') ||
                               link.name.includes('Multi Audio') ||
                               link.name.toLowerCase().includes('multi');

                  let simplifiedName = link.name
                      .replace(/1080|720|UHD|MultiAudio|Multi Audio|\(.*?\)/g, '')
                      .replace(/\s+/g, ' ')
                      .trim();
                  
                  for (const key in nameMap) {
                      if (simplifiedName.includes(key)) {
                          simplifiedName = simplifiedName.replace(key, nameMap[key]);
                          break; 
                      }
                  }

                  simplifiedName = normalizeChannelName(simplifiedName);

                  numberedChannels.push({
                      id: acestreamId,
                      number: currentNumber.toString(),
                      name: simplifiedName,
                      quality: quality,
                      multiAudio: multiAudio,
                      isKnown: true,
                      source: 'elcano'
                  });
                  trackFirstSeen(acestreamId);

                  currentNumber++;
              }
          });

          return numberedChannels;
      }

      function processEventsData(htmlContent) {
          const numberedChannels = [];
          const parser = new DOMParser();
          const doc = parser.parseFromString(htmlContent, 'text/html');
          const dateHeaders = doc.querySelectorAll('h2.fecha');
          
          let currentNumber = RANGES.EV.start;
          
          const channelMappings = {
              'Movistar': 'M+',
              'LaLiga': 'La Liga',
              'Premier': 'Premier League',
              'Eurosport': '‚òÖEUROSPORT',
              'Copa del Rey': 'Copa del Rey',
              'Liga de Campeones': 'Liga de Campeones'
          };

          dateHeaders.forEach(dateHeader => {
              const date = dateHeader.textContent.trim();
              const table = dateHeader.nextElementSibling;
              
              if (table && table.tagName.toLowerCase() === 'table') {
                  const rows = table.querySelectorAll('tbody tr');
                  
                  rows.forEach(row => {
                      const cells = row.querySelectorAll('td');
                      if (cells.length >= 5) {
                          const time = cells[0].textContent.trim();
                          const sportCell = cells[1];
                          const sportEmoji = sportCell ? sportCell.firstChild.textContent.trim() : '';
                          const sportName = sportCell ? sportCell.querySelector('.deporte').textContent.trim() : '';

                          const competition = cells[2].textContent.trim();
                          const match = cells[3].textContent.trim();
                          const canalesCell = cells[4];
                          const links = canalesCell.querySelectorAll('a[href^="acestream://"]');
                          
                          if (links.length > 0) {
                              links.forEach(link => {
                                  const acestreamId = link.href.split('://')[1];
                                  let channelName = link.textContent.trim();
                                  
                                  for (const key in channelMappings) {
                                      const regex = new RegExp(key, 'gi');
                                      channelName = channelName.replace(regex, channelMappings[key]);
                                  }
                                  
                                  let simplifiedName = channelName
                                      .replace(/Estable|New Era II|New Era I|New Era VI|1080|720|UHD|MultiAudio|Multi Audio|\(.*?\)/g, '')
                                      .replace(/\s+/g, ' ')
                                      .trim();
                                  
                                  let quality = '720p';
                                  if (channelName.includes('1080')) quality = '1080p';
                                  if (channelName.includes('UHD')) quality = 'UHD';
                                  
                                  const multiAudio = false;
                                  
                                  numberedChannels.push({
                                      id: acestreamId,
                                      number: currentNumber.toString(),
                                      name: simplifiedName,
                                      quality: quality,
                                      multiAudio: multiAudio,
                                      isKnown: true,
                                      source: 'events',
                                      event: { time, competition, match, date, sportEmoji, sportName }
                                  });
                                  trackFirstSeen(acestreamId);
                                  
                                  currentNumber++;
                              });
                          }
                      }
                  });
              }
          });
          
          return numberedChannels;
      }
      
      function processChannelNames() {
          const brands = [
              { name: 'M+', class: 'movistar' },
              { name: '‚òÖEurosport', class: 'eurosport' },
              { name: 'DAZN', class: 'dazn' },
              { name: 'F1', class: 'f1' },
              { name: 'Acci√≥n', class: 'action' },
              { name: 'Deportes', class: 'sports' },
              { name: 'hits', class: 'action' },
              { name: 'cl√°sicos', class: 'action' },
              { name: 'Cl√°sicos', class: 'classics' },
              { name: 'Vamos', class: 'vamos' },
              { name: 'Copa del Rey', class: 'copadelrey' },
              { name: 'Liga de Campeones', class: 'champions' },
              { name: 'La Liga', class: 'liga' },
              { name: 'Hypermotion', class: 'hypermotion' },
              { name: 'Golf', class: 'golf' },
              { name: '‚òÖEUROSPORT\\d+', class: 'eurosport-number', regex: true },
              { name: 'Smartbank', class: 'smartbank' },
              { name: 'Plus', class: 'plus' },
              { name: 'Western', class: 'western' },
              { name: 'Documentales', class: 'documentary' },
              { name: 'Originales', class: 'originals' },
              { name: 'Hits', class: 'hits' },
              { name: 'Estrenos', class: 'premieres' },
              { name: 'Indie', class: 'indie' },
              { name: 'Cine Espa√±ol', class: 'spanish-film' },
              { name: 'Drama', class: 'drama' },
              { name: 'Ellas', class: 'ellas' },
              { name: 'Series', class: 'series' }
          ];

          state.channelsData.forEach(channel => {
              let result = channel.name;
              brands.forEach(brand => {
                  if (brand.regex) {
                      const regex = new RegExp(`(${brand.name})`, 'gi');
                      result = result.replace(regex, `<span class="${brand.class}">$1</span>`);
                  } else {
                      const escapedName = brand.name.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                      const regex = new RegExp(`(${escapedName})`, 'gi');
                      result = result.replace(regex, `<span class="${brand.class}">$1</span>`);
                  }
              });
              const comediaRegex = /(comedia)/gi;
              result = result.replace(comediaRegex, '<span class="degradado-comedia">Comedia</span>');
              channel.displayableName = result;
          });
      }

      // MODIFICACI√ìN DE filterChannels para incluir el filtrado por deporte
      function filterChannels() {
        let filteredChannels = state.channelsData;
        const searchTerm = document.getElementById('searchInput').value.trim().toLowerCase();
        
        let currentFilter = state.currentFilter;
        
        // 1. Filtrado por Marca (DAZN, Movistar, Eurosport, etc.)
        if(currentFilter !== 'all' && currentFilter !== 'favorites' && currentFilter !== 'history') {
             filteredChannels = filteredChannels.filter(channel =>
                normalizeText(channel.name).includes(normalizeText(currentFilter))
            );
        }

        // 2. Filtrado por Favoritos/Historial
        if (state.currentFilter === 'favorites') {
            filteredChannels = filteredChannels.filter(c => state.favorites.includes(c.id));
        } else if (state.currentFilter === 'history') {
            const historyChannels = Object.entries(state.channelHistory).map(([number, data]) => {
                return {
                    id: data.id,
                    number,
                    name: data.names[0] || `Canal ${number}`,
                    quality: 'N/A',
                    multiAudio: false,
                    isKnown: true,
                    source: 'history'
                };
            });
            filteredChannels = historyChannels;
        }

        // 3. NUEVO FILTRADO POR DEPORTE
        if (state.sportFilter !== 'all') {
            const normalizedSportFilter = normalizeText(state.sportFilter);
            
            const sportSearchTerms = {
                'futbol': ['futbol', 'soccer', 'campeones', 'copa del rey', 'premier', 'bundesliga', 'serie a'],
                'baloncesto': ['baloncesto', 'basket', 'nba', 'euroliga'],
                'tenis': ['tenis', 'wimbledon', 'roland garros', 'us open', 'atp', 'wta'],
                'boxeo': ['boxeo', 'boxing', 'lucha', 'ufc', 'mma'],
                'ciclismo': ['ciclismo', 'tour', 'giro', 'vuelta'],
                'motorsport': ['motor', 'f1', 'f√≥rmula', 'formula', 'moto', 'motociclismo', 'dakar', 'rally', 'motogp', 'wrc', 'nascar'],
                'f1': ['f1', 'f√≥rmula 1', 'formula 1', 'formulaone', 'f√≥rmulaone']
            };
            
            const targetTerms = sportSearchTerms[normalizedSportFilter] || [normalizedSportFilter];
            
            filteredChannels = filteredChannels.filter(channel => {
                const normalizedName = normalizeText(channel.name);
                
                // Buscar en el nombre del canal o en los detalles del evento
                const eventDetailsMatch = channel.event && (
                    normalizeText(channel.event.sportName || '').includes(normalizedSportFilter) ||
                    targetTerms.some(term => normalizeText(channel.event.competition || '').includes(term)) ||
                    targetTerms.some(term => normalizeText(channel.event.match || '').includes(term))
                );
                
                const nameMatch = targetTerms.some(term => normalizedName.includes(term));
                
                return eventDetailsMatch || nameMatch;
            });
        }

        // 4. Filtrado por T√©rmino de B√∫squeda
        if (searchTerm) {
          filteredChannels = filteredChannels.filter(channel => {
            const normalizedSearchTerm = normalizeText(searchTerm);
            
            const nameMatches = normalizeText(channel.name).includes(normalizedSearchTerm);
            const numberMatches = channel.number && channel.number.includes(searchTerm.replace('#', ''));
            
            let eventDetailsMatch = false;
            if (channel.event) {
                const { time, competition, match, date, sportName } = channel.event;
                eventDetailsMatch = 
                    normalizeText(time || '').includes(normalizedSearchTerm) ||
                    normalizeText(sportName || '').includes(normalizedSearchTerm) ||
                    normalizeText(competition || '').includes(normalizedSearchTerm) ||
                    normalizeText(match || '').includes(normalizedSearchTerm) ||
                    normalizeText(date || '').includes(normalizedSearchTerm); 
            }

            return nameMatches || numberMatches || eventDetailsMatch;
          });
        }

        return filteredChannels;
      }

      function standardizeQuality(quality) {
        if (!quality) return 'SD';
        quality = quality.toLowerCase();
        if (quality.includes('uhd') || quality.includes('4k')) {
            return '4K';
        }
        if (quality.includes('1080') || quality.includes('fhd')) {
            return 'FHD';
        }
        if (quality.includes('720') || quality.includes('hd')) {
            return 'HD';
        }
        return 'SD';
      }

      function getChannelNumberFromName(name) {
          const match = name.match(/\d+/);
          return match ? parseInt(match[0], 10) : 1;
      }

      function renderResults() {
          const filteredChannels = filterChannels();
          const channelsGrid = document.getElementById('channelsGrid');
          
          channelsGrid.innerHTML = '';
          
          if (filteredChannels.length === 0) {
            channelsGrid.innerHTML = `
                <div class="no-results">
                    <div class="no-results-icon">üì°</div>
                    <div class="no-results-text">No se encontraron canales</div>
                    <div class="no-results-hint">Prueba con otros filtros o t√©rminos de b√∫squeda</div>
                </div>
            `;
            return;
          }

          const sortedChannels = [...filteredChannels].sort((a, b) => {
              const aIsOff = a.name.includes('(OFF)');
              const bIsOff = b.name.includes('(OFF)');
              
              if (aIsOff && !bIsOff) return 1;
              if (!aIsOff && bIsOff) return -1;
              
              const nameNumberA = getChannelNumberFromName(a.name);
              const nameNumberB = getChannelNumberFromName(b.name);
              if (nameNumberA !== nameNumberB) {
                  return nameNumberA - nameNumberB;
              }

              const qualityMap = { '4K': 5, 'FHD': 4, 'HD': 3, 'SD': 2, 'N/A': 1, 'UHD': 6 };
              const qualityA = qualityMap[standardizeQuality(a.quality)] || 0;
              const qualityB = qualityMap[standardizeQuality(b.quality)] || 0;
              if (qualityB !== qualityA) {
                  return qualityB - qualityA;
              }

              const sourcePriorityMap = { 'gist': 4, 'events': 3, 'shickat': 2, 'elcano': 1, 'history': 0 };
              const sourceA = sourcePriorityMap[a.source] || 0;
              const sourceB = sourcePriorityMap[b.source] || 0;
              if (sourceB !== sourceA) {
                  return sourceB - sourceA;
              }

              const numA = parseInt(a.number, 10);
              const numB = parseInt(b.number, 10);
              return numA - numB;
          });

          const groups = {};
          const otherChannels = [];
          
          const groupOrder = [
              'DAZN F1', 
              'DAZN',
              'DAZN La Liga',
              'M+ La Liga', 
              'Liga de Campeones', 
              'La Liga Hypermotion', 
              'M+ Vamos', 
              'M+ Deportes',
              'M+ Plus', 
              'M+ Golf', 
              'M+',
              '‚òÖEUROSPORT'
          ];

          const groupRegexes = {
              'DAZN F1': /DAZN F1/i,
              'DAZN': /DAZN/i,
              'DAZN La Liga': /DAZN La Liga/i,
              'Liga de Campeones': /Liga de Campeones/i,
              'La Liga Hypermotion': /La Liga Hypermotion/i,
              'M+ La Liga': /M\+ La Liga/i,
              'M+ Vamos': /M\+ Vamos/i,
              'M+ Deportes': /M\+ Deportes/i,
              'M+ Plus': /M\+ Plus/i,
              'M+ Golf': /M\+ Golf/i,
              'M+': /M\+/i,
              '‚òÖEUROSPORT': /‚òÖEUROSPORT/i,
          };
          
          sortedChannels.forEach(channel => {
              if (channel.source === 'events' && channel.event) {
                  const eventGroupKey = `${channel.event.date}-${channel.event.time}-${channel.event.competition}-${channel.event.match}`;
                  if (!groups[eventGroupKey]) {
                      groups[eventGroupKey] = { name: `${channel.event.competition}: ${channel.event.match}`, channels: [], time: channel.event.time, date: channel.event.date, isEvent: true, sportEmoji: channel.event.sportEmoji, sportName: channel.event.sportName };
                  }
                  groups[eventGroupKey].channels.push(channel);
              } else {
                  let groupFound = false;

                  // L√≥gica espec√≠fica para ELEVEN DAZN y DAZN EVENTOS
                  if (channel.name.toUpperCase().includes('ELEVEN DAZN') || channel.name.toUpperCase().includes('DAZN EVENTOS')) {
                      if (!groups['Otros']) {
                          groups['Otros'] = { name: 'Otros', channels: [] };
                      }
                      groups['Otros'].channels.push(channel);
                      groupFound = true;
                  } else {
                      for (const groupName of groupOrder) {
                          if (groupName === 'DAZN' && /DAZN La Liga/i.test(channel.name)) {
                              continue;
                          }
                          if (groupRegexes[groupName] && groupRegexes[groupName].test(channel.name)) {
                              if (!groups[groupName]) {
                                  groups[groupName] = { name: groupName, channels: [] };
                              }
                              groups[groupName].channels.push(channel);
                              groupFound = true;
                              break;
                          }
                      }
                  }
                  
                  if (!groupFound) {
                      if (!groups['Otros']) {
                          groups['Otros'] = { name: 'Otros', channels: [] };
                      }
                      groups['Otros'].channels.push(channel);
                  }
              }
          });

          const sortedGroupKeys = Object.keys(groups).sort((a, b) => {
              const groupA = groups[a];
              const groupB = groups[b];

              if (groupA.isEvent && groupB.isEvent) {
                  return compareEventDates(groupA, groupB);
              }

              if (groupA.isEvent && !groupB.isEvent) return -1;
              if (!groupA.isEvent && groupB.isEvent) return 1;

              const indexA = groupOrder.indexOf(a);
              const indexB = groupOrder.indexOf(b);
              
              if (indexA === -1 && indexB === -1) {
                  return a.localeCompare(b);
              }
              if (indexA === -1) return 1;
              if (indexB === -1) return -1;
              
              return indexA - indexB;
          });

          if (groups['Otros']) {
              sortedGroupKeys.push(sortedGroupKeys.splice(sortedGroupKeys.indexOf('Otros'), 1)[0]);
          }
          
          const fragment = document.createDocumentFragment();
          sortedGroupKeys.forEach(groupKey => {
              const group = groups[groupKey];
              const groupElement = document.createElement('div');
              groupElement.className = 'channel-group';

              let groupTitleContent;
              if (group.isEvent) {
                  groupTitleContent = `
                      <div style="display: flex; flex-direction: column; width: 100%;">
                        <div style="display: flex; justify-content: space-between; width: 100%;">
                          <div>${group.date}</div>
                          <div class="group-title-emoji">${group.sportEmoji}</div>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                          <div style="margin-right: 10px;">${group.channels[0].event.time}</div>
                          <div class="marquee-container" style="flex: 1;">
                            <div class="competition-text">${group.channels[0].event.competition}</div>
                          </div>
                          <div style="margin-left: 10px;">${group.channels[0].event.match}</div>
                        </div>
                      </div>
                  `;
              } else {
                  groupTitleContent = `<div>${group.name}</div>`;
              }

              groupElement.innerHTML = `
                  <div class="channel-group__header">
                    <div class="channel-group__title">${groupTitleContent}</div>
                  </div>
                  <div class="channel-group__content">
                    ${group.channels.map(channel => createChannelCard(channel)).join('')}
                  </div>
              `;
              fragment.appendChild(groupElement);
          });
          channelsGrid.appendChild(fragment);

          document.querySelectorAll('.competition-text').forEach(textElement => {
              const container = textElement.closest('.marquee-container');
              if (container && textElement.scrollWidth > container.clientWidth) {
                  textElement.classList.add('is-overflowing');
              } else {
                  textElement.classList.remove('is-overflowing');
              }
          });
      }

      function compareEventDates(eventA, eventB) {
          const today = new Date();
          const isTodayA = eventA.date.toLowerCase() === 'hoy';
          const isTodayB = eventB.date.toLowerCase() === 'hoy';

          if (isTodayA && !isTodayB) return -1;
          if (!isTodayA && isTodayB) return 1;

          if (isTodayA && isTodayB) {
              const timeA = eventA.time.replace(':', '');
              const timeB = eventB.time.replace(':', '');
              return parseInt(timeA, 10) - parseInt(timeB, 10);
          }

          const dateA = parseDateString(eventA.date, today);
          const dateB = parseDateString(eventB.date, today);

          if (dateA.getTime() !== dateB.getTime()) {
              return dateA.getTime() - dateB.getTime();
          }

          const timeA = eventA.time.replace(':', '');
          const timeB = eventB.time.replace(':', '');
          return parseInt(timeA, 10) - parseInt(timeB, 10);
      }

      function parseDateString(dateString, today) {
          if (dateString.toLowerCase() === 'ma√±ana') {
              const tomorrow = new Date(today);
              tomorrow.setDate(today.getDate() + 1);
              return tomorrow;
          }
          const parts = dateString.split('/');
          if (parts.length === 3) {
              return new Date(parseInt(parts[2]), parseInt(parts[1]) - 1, parseInt(parts[0]));
          }
          return today;
      }

      function createChannelCard(channel) {
          const isFavorite = state.favorites.includes(channel.id);
          const cardClass = `channel-card ${isFavorite ? 'channel-card--favorite' : ''} ${state.isFavoriteMode ? 'channel-card--favorite-mode' : ''}`;
          
          const rating = state.channelRatings[channel.id] !== undefined ? state.channelRatings[channel.id] : 2.5;

          let sourceBadgeClass = '';
          let sourceBadgeText = '';
          const channelNumber = parseInt(channel.number, 10);

          for (const key in RANGES) {
              if (channelNumber >= RANGES[key].start && channelNumber <= RANGES[key].end) {
                  switch (key) {
                      case 'NE':
                          sourceBadgeClass = 'gist-badge';
                          sourceBadgeText = 'NE';
                          break;
                      case 'EC':
                          sourceBadgeClass = 'elcano-badge';
                          sourceBadgeText = 'EC';
                          break;
                      case 'EV':
                          sourceBadgeClass = 'events-badge';
                          sourceBadgeText = 'EV';
                          break;
                      case 'SH':
                          sourceBadgeClass = 'shickat-badge';
                          sourceBadgeText = 'SH';
                          break;
                  }
                  break;
              }
          }
          
          const isNew = isChannelNew(channel.id);
          const newIndicator = isNew ? '<div class="new-channel-indicator"></div>' : '';

          const displayQuality = standardizeQuality(channel.quality);

          return `
              <div class="${cardClass}"
                   data-id="${channel.id}"
                   data-number="${channel.number}">
                  ${newIndicator}
                  <div class="channel-card__quality">
                      ${displayQuality} ${channel.multiAudio ? 'üéß' : ''}
                  </div>
                  <div class="channel-header">
                      <div class="channel-name">${channel.displayableName}</div>
                  </div>
                  <div class="channel-number-badge ${sourceBadgeClass}">
                      <span class="channel-number">${channel.number}</span>
                      <span class="source-initials">${sourceBadgeText}</span>
                  </div>
                  <div class="rating-stars">${getStarRating(rating)}</div>
              </div>
          `;
      }

      function playChannel(acestreamId) {
          const acestreamUrl = `acestream://${acestreamId}`;
          const newWindow = window.open(acestreamUrl, '_blank');
          
          setTimeout(() => {
              if (newWindow && newWindow.closed) {
              } else {
              }
          }, 500);
      }
      
      let currentCard = null;
      let isSwiping = false;
      const SWIPE_THRESHOLD = 80;
      const VERTICAL_TOLERANCE = 40;
      let longPressTimer;
      let isLongPress = false;
      
      let touchStartX = 0;
      let touchStartY = 0;
      let touchStartTime = 0;
      const TAP_THRESHOLD_TIME = 200;
      const TAP_THRESHOLD_DISTANCE = 10;

      function handleChannelPlay(channel) {
          if (isSwiping) {
              isSwiping = false;
              return;
          }
          const now = new Date().getTime();

          if (state.lastChannelPlay) {
              const previousChannelId = state.lastChannelPlay.channelId;
              const previousChannelData = state.channelsData.find(c => c.id === previousChannelId);
              const duration = (now - state.lastChannelPlay.timestamp) / 1000;
              
              let rating = state.channelRatings[previousChannelId] !== undefined ? state.channelRatings[previousChannelId] : 2.5;
              let newRating = rating;

              const previousName = previousChannelData ? previousChannelData.name.toLowerCase().trim() : '';
              const currentName = channel.name.toLowerCase().trim();

              if (previousName === currentName) {
                  if (duration >= (30 * 60)) {
                      newRating += 1.5;
                  } else if (duration >= (15 * 60)) {
                      newRating -= 0.5;
                  } else if (duration >= (5 * 60)) {
                      newRating -= 1;
                  } else if (duration >= 10) {
                      newRating -= 1.5;
                  }
              } else {
                  if (duration >= (30 * 60)) {
                      newRating += 1.5;
                  } else {
                      newRating = rating;
                  }
              }

              state.channelRatings[previousChannelId] = Math.max(1, Math.min(5, newRating));
              saveRatings();
              renderResults();
          }

          state.lastChannelPlay = {
              channelId: channel.id,
              timestamp: now
          };
          localStorage.setItem('lastChannelPlay', JSON.stringify(state.lastChannelPlay));

          playChannel(channel.id);
      }

      function handleTap(event) {
        if (!currentCard || isSwiping) {
            return;
        }

        if (state.isFavoriteMode) {
            const channelId = currentCard.dataset.id;
            toggleFavorite(channelId);
            const channelCard = document.querySelector(`[data-id="${channelId}"]`);
            if (state.favorites.includes(channelId)) {
                channelCard.classList.add('channel-card--favorite');
            } else {
                channelCard.classList.remove('channel-card--favorite');
            }
        } else {
            const channelId = currentCard.dataset.id;
            const channelData = state.channelsData.find(c => c.id === channelId);
            if (channelData) {
                handleChannelPlay(channelData);
            }
        }
      }

      function showCopyModal(acestreamId) {
          const url = `acestream://${acestreamId}`;
          const copyModal = document.getElementById('copyModal');
          const confirmBtn = document.getElementById('confirmCopyBtn');
          const urlDisplay = document.getElementById('copyUrlDisplay');

          urlDisplay.textContent = url;
          
          confirmBtn.onclick = () => copyUrlToClipboard(acestreamId);
          copyModal.classList.add('active');
      }

      function hideCopyModal() {
          document.getElementById('copyModal').classList.remove('active');
      }

      function showCopySuccessMessage() {
          const messageElement = document.getElementById('copyMessage');
          messageElement.classList.add('show');
          setTimeout(() => {
              messageElement.classList.remove('show');
          }, 2000);
      }

      async function copyUrlToClipboard(acestreamId) {
          const url = `acestream://${acestreamId}`;
          try {
              await navigator.clipboard.writeText(url);
              hideCopyModal();
              showCopySuccessMessage();
          } catch (err) {
              console.error('Error al copiar el texto: ', err);
              alert('No se pudo copiar la URL. Por favor, hazlo manualmente.');
          }
      }

      function handleSearchInput() {
        state.searchTerm = document.getElementById('searchInput').value.trim();
        document.querySelectorAll('.filter-button').forEach(btn => btn.classList.remove('filter-button--active'));
        document.querySelectorAll('.sport-filter-button').forEach(btn => btn.classList.remove('filter-button--active'));
        renderResults();
      }

      function changePrimaryColor(color) {
        state.primaryColor = color;
        const rgb = hexToRgb(color);
        document.documentElement.style.setProperty('--primary-rgb', `${rgb.r}, ${rgb.g}, ${rgb.b}`);
        document.documentElement.style.setProperty('--primary', color);
        document.documentElement.style.setProperty('--primary-dark', shadeColor(color, -20));
        updatePrimaryLightColor();
        document.querySelectorAll('.color-option').forEach(btn => {
          btn.classList.remove('active');
        });
        document.querySelector(`.color-option[data-color="${color}"]`).classList.add('active');
        localStorage.setItem('primaryColor', color);
        renderResults();
      }

      function hexToRgb(hex) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return { r, g, b };
      }

      function shadeColor(color, percent) {
        let R = parseInt(color.substring(1,3), 16);
        let G = parseInt(color.substring(3,5), 16);
        let B = parseInt(color.substring(5,7), 16);

        R = (R<255)?R:255;  
        G = (G<255)?G:255;  
        B = (B<255)?B:255;  

        return `#${R.toString(16).padStart(2,'0')}${G.toString(16).padStart(2,'0')}${B.toString(16).padStart(2,'0')}`;
      }

      function updatePrimaryLightColor() {
        const rgb = hexToRgb(state.primaryColor);
        const isDarkMode = document.body.classList.contains('dark-mode');
        document.documentElement.style.setProperty('--primary-light', 
          isDarkMode ? `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.2)` : `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.1)`);
      }
      
      function cleanObsoleteRatings() {
        const activeChannelIds = new Set(state.channelsData.map(c => c.id));
        const ratingsToKeep = {};

        for (const channelId in state.channelRatings) {
            if (activeChannelIds.has(channelId)) {
                ratingsToKeep[channelId] = state.channelRatings[channelId];
            }
        }
        state.channelRatings = ratingsToKeep;
        saveRatings();
        console.log("Puntuaciones de canales obsoletas limpiadas.");
      }

      function saveRatings() {
          localStorage.setItem('channelRatings', JSON.stringify(state.channelRatings));
      }

      function resetRatings() {
          if (confirm('¬øEst√°s seguro de que quieres restablecer todas las puntuaciones de los canales?')) {
              localStorage.removeItem('channelRatings');
              state.channelRatings = {};
              renderResults();
              showStatusMessage("Puntuaciones de canales restablecidas.", "success");
              document.getElementById('settingsModal').classList.remove('modal--active');
          }
      }

      function getStarRating(score) {
          const fullStars = Math.floor(score);
          const hasHalfStar = score % 1 >= 0.5;
          let stars = '‚òÖ'.repeat(fullStars);
          if (hasHalfStar) {
              stars += '<span class="half-star">‚òÖ</span>';
          }
          const emptyStars = '‚òÜ'.repeat(5 - fullStars - (hasHalfStar ? 1 : 0));
          return `<span style="color: var(--primary);">${stars}</span><span style="color: gray;">${emptyStars}</span>`;
      }

      document.addEventListener('DOMContentLoaded', () => {
          document.body.classList.toggle('dark-mode', state.darkMode);
          document.getElementById('darkModeCheckbox').checked = state.darkMode;
          
          let pressTimerFav;
          const favoriteButton = document.getElementById('filterFavorites');
          const LONG_PRESS_THRESHOLD = 500;
          
          let pressTimerClear;
          const clearButton = document.getElementById('clearEmojiFilters');
          const copyModal = document.getElementById('copyModal');
          const cancelCopyBtn = document.getElementById('cancelCopyBtn');

          cleanupOldFirstSeenRecords();

          favoriteButton.addEventListener('mousedown', (e) => {
              if (e.button !== 0) return;
              pressTimerFav = setTimeout(() => {
                  state.isFavoriteMode = !state.isFavoriteMode;
                  
                  if (state.isFavoriteMode) {
                      showStatusMessage("Modo de selecci√≥n de favoritos activado. Pulsa un canal para marcarlo/desmarcarlo.");
                  } else {
                      showStatusMessage("Modo de selecci√≥n de favoritos desactivado.", "success");
                  }
                  
                  renderResults();
                  pressTimerFav = null;
              }, LONG_PRESS_THRESHOLD);
          });

          favoriteButton.addEventListener('mouseup', () => {
              clearTimeout(pressTimerFav);
              if (pressTimerFav) {
                  applyFilter('favorites');
              }
          });
          
          favoriteButton.addEventListener('touchstart', () => {
              pressTimerFav = setTimeout(() => {
                  state.isFavoriteMode = !state.isFavoriteMode;
                  
                  if (state.isFavoriteMode) {
                      showStatusMessage("Modo de selecci√≥n de favoritos activado. Pulsa un canal para marcarlo/desmarcarlo.");
                  } else {
                      showStatusMessage("Modo de selecci√≥n de favoritos desactivado.", "success");
                  }
                  
                  renderResults();
                  pressTimerFav = null;
              }, LONG_PRESS_THRESHOLD);
          });

          favoriteButton.addEventListener('touchend', () => {
              clearTimeout(pressTimerFav);
              if (pressTimerFav) {
                  applyFilter('favorites');
              }
          });
          
          clearButton.addEventListener('mousedown', (e) => {
              if (e.button !== 0) return;
              pressTimerClear = setTimeout(() => {
                  document.getElementById('settingsModal').classList.add('modal--active');
                  pressTimerClear = null;
              }, LONG_PRESS_THRESHOLD);
          });

          clearButton.addEventListener('mouseup', () => {
              clearTimeout(pressTimerClear);
              if (pressTimerClear) {
                  applyFilter('all');
              }
          });

          clearButton.addEventListener('touchstart', () => {
              pressTimerClear = setTimeout(() => {
                  document.getElementById('settingsModal').classList.add('modal--active');
                  pressTimerClear = null;
              }, LONG_PRESS_THRESHOLD);
          });

          clearButton.addEventListener('touchend', () => {
              clearTimeout(pressTimerClear);
              if (pressTimerClear) {
                  applyFilter('all');
              }
          });
          
          if(cancelCopyBtn) {
              cancelCopyBtn.addEventListener('click', hideCopyModal);
          }
          
          window.addEventListener('click', (event) => {
              if (event.target === copyModal) {
                  hideCopyModal();
              }
          });


          document.getElementById('filterDAZN').addEventListener('click', () => applyFilter('dazn'));
          document.getElementById('filterMovistar').addEventListener('click', () => applyFilter('m+'));
          document.getElementById('filterEurosport').addEventListener('click', () => applyFilter('eurosport'));
          
          // Listeners para los NUEVOS filtros de Deporte
          document.querySelectorAll('.sport-filter-button').forEach(button => {
              button.addEventListener('click', () => {
                  applySportFilter(button.dataset.sportKey);
              });
          });
          
          document.getElementById('searchInput').addEventListener('input', handleSearchInput);
          document.getElementById('darkModeCheckbox').addEventListener('change', toggleDarkMode);
          document.getElementById('closeSettingsBtn').addEventListener('click', () => document.getElementById('settingsModal').classList.remove('modal--active'));

          document.querySelectorAll('.color-option').forEach(btn => {
              btn.addEventListener('click', () => changePrimaryColor(btn.dataset.color));
          });
          changePrimaryColor(state.primaryColor);
          
          applyFilter('all');
          loadInitialChannels();
      });

      document.addEventListener('mousedown', (e) => {
          if (e.target.closest('.channel-card')) {
              currentCard = e.target.closest('.channel-card');
              touchStartX = e.clientX;
              touchStartY = e.clientY;
              touchStartTime = new Date().getTime();
              isSwiping = false;
          }
      });

      document.addEventListener('mousemove', (e) => {
          if (!currentCard) return;

          const diffX = e.clientX - touchStartX;
          const diffY = e.clientY - touchStartY;

          if (Math.abs(diffX) > SWIPE_THRESHOLD && Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffY) < VERTICAL_TOLERANCE) {
              isSwiping = true;
              e.preventDefault(); 
              showCopyModal(currentCard.dataset.id);
              currentCard = null; 
          }
      });

      document.addEventListener('mouseup', (e) => {
          if (currentCard) {
              if (!isSwiping) {
                const mouseUpTime = new Date().getTime();
                const touchDuration = mouseUpTime - touchStartTime;
                const touchDistanceX = Math.abs(e.clientX - touchStartX);
                const touchDistanceY = Math.abs(e.clientY - touchStartY);

                if (touchDuration < TAP_THRESHOLD_TIME && touchDistanceX < TAP_THRESHOLD_DISTANCE && touchDistanceY < TAP_THRESHOLD_DISTANCE) {
                    handleTap(e);
                }
              }
          }
          currentCard = null;
          isSwiping = false;
      });

      document.addEventListener('touchstart', (e) => {
          if (e.target.closest('.channel-card')) {
              e.stopPropagation(); 
              currentCard = e.target.closest('.channel-card');
              const touch = e.touches[0];
              touchStartX = touch.clientX;
              touchStartY = touch.clientY;
              touchStartTime = new Date().getTime();
              isSwiping = false; 
              longPressTimer = setTimeout(() => {
                  isLongPress = true;
              }, 500);
          }
      }, {passive: false});

      document.addEventListener('touchmove', (e) => {
          if (!currentCard) return;
          const touch = e.touches[0];
          const diffX = touch.clientX - touchStartX;
          const diffY = touch.clientY - touchStartY;

          if (Math.abs(diffX) > SWIPE_THRESHOLD && Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffY) < VERTICAL_TOLERANCE) {
              isSwiping = true;
              e.preventDefault(); 
              showCopyModal(currentCard.dataset.id);
              currentCard = null;
              clearTimeout(longPressTimer);
          }
      }, {passive: false});

      document.addEventListener('touchend', (e) => {
          if (isLongPress) {
              isLongPress = false;
              clearTimeout(longPressTimer);
              return;
          }

          if (currentCard) {
              if (!isSwiping) {
                  const endElement = document.elementFromPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
                  const touchEndTime = new Date().getTime();
                  const touchDuration = touchEndTime - touchStartTime;
                  const touchDistanceX = Math.abs(e.changedTouches[0].clientX - touchStartX);
                  const touchDistanceY = Math.abs(e.changedTouches[0].clientY - touchStartY);

                  if (endElement && endElement.closest('.channel-card') === currentCard && touchDuration < TAP_THRESHOLD_TIME && touchDistanceX < TAP_THRESHOLD_DISTANCE && touchDistanceY < TAP_THRESHOLD_DISTANCE) {
                    handleTap(e);
                  }
              }
          }
          currentCard = null;
          isSwiping = false;
      });
    </script>
</body>
</html>

